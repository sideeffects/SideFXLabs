MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY"

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename=".OPfallbacks"
Content-Type: application/external-reference

.OPfallbacks

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename=".OPdummydefs"
Content-Type: application/external-reference

.OPdummydefs

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="node_type"
Content-Type: text/plain

Sop

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.init"
Content-Type: text/plain

type = labs::2d_wavefunctioncollapse::1.0
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position 2.34921 -33.8207
connectornextid 3
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
2 "output1"
}
inputsNamed3
{
0 	wfc_initialize1 0 1 "input1"
1 	wfc_sample_paint1 1 1 "input2"
}
inputs
{
0 	wfc_initialize1 0 1
1 	wfc_sample_paint1 0 1
}
stat
{
  create 1583350383
  modify 1583365894
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"0.1"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.inp"
Content-Type: text/plain

2
0 -2.1906799922905118 7.4523399934196473 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
1 1.8911400111758709 7.4523399934196473 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribwrangle1.init"
Content-Type: text/plain

type = attribwrangle
matchesdef = 1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribwrangle1.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position -2.19368 4.41743
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	OutputGrid 1 1 "input1"
}
inputs
{
0 	OutputGrid 0 1
}
stat
{
  create 1580064098
  modify 1581467637
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribwrangle1.parm"
Content-Type: text/plain

{
version 0.8
folder0	[ 0	locks=0 ]	(	0	0	)
group	[ 0	locks=0 ]	(	""	)
grouptype	[ 0	locks=0 ]	(	"guess"	)
class	[ 0	locks=0 ]	(	"point"	)
vex_numcount	[ 0	locks=0 ]	(	10	)
vex_threadjobsize	[ 0	locks=0 ]	(	1024	)
snippet	[ 0	locks=0 ]	(	"if (haspointattrib(0, \"name\") == 0 || string(point(0, \"name\", @ptnum)) == \"\") {
    s@name = \"WFC_Initialize\";
}

"	)
exportlist	[ 0	locks=0 ]	(	*	)
vex_strict	[ 0	locks=0 ]	(	"off"	)
autobind	[ 0	locks=0 ]	(	"on"	)
bindings	[ 0	locks=0 ]	(	0	)
groupautobind	[ 0	locks=0 ]	(	"on"	)
groupbindings	[ 0	locks=0 ]	(	0	)
vex_cwdpath	[ 0	locks=0 ]	(	.	)
vex_outputmask	[ 0	locks=0 ]	(	*	)
vex_updatenmls	[ 0	locks=0 ]	(	"off"	)
vex_matchattrib	[ 0	locks=0 ]	(	id	)
vex_inplace	[ 0	locks=0 ]	(	"off"	)
vex_selectiongroup	[ 0	locks=0 ]	(	""	)
vex_precision	[ 0	locks=0 ]	(	auto	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribwrangle1.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/calcinputsize.init"
Content-Type: text/plain

type = attribwrangle
matchesdef = 1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/calcinputsize.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position 1.88814 4.41743
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	IncomingSampleGrid 1 1 "input1"
}
inputs
{
0 	IncomingSampleGrid 0 1
}
stat
{
  create 1580773086
  modify 1581484215
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/calcinputsize.parm"
Content-Type: text/plain

{
version 0.8
folder0	[ 0	locks=0 ]	(	0	0	)
group	[ 0	locks=0 ]	(	""	)
grouptype	[ 0	locks=0 ]	(	"guess"	)
class	[ 0	locks=0 ]	(	"detail"	)
vex_numcount	[ 0	locks=0 ]	(	10	)
vex_threadjobsize	[ 0	locks=0 ]	(	1024	)
snippet	[ 0	locks=0 ]	(	"vector point1pos = point(0, \"P\", 0);
point1pos.y = 0;
vector point2pos = point(0, \"P\", 1);
point2pos.y = 0;
float pointdistance = distance(point1pos, point2pos);
vector size = getpointbbox_size(0);
size.x += pointdistance;
size.z += pointdistance;

int gridresolutionX = int(size.x / pointdistance);
int gridresolutionZ = int(size.z / pointdistance);

i@SampleGridResolutionX = gridresolutionX;
i@SampleGridResolutionZ = gridresolutionZ;
"	)
exportlist	[ 0	locks=0 ]	(	*	)
vex_strict	[ 0	locks=0 ]	(	"off"	)
autobind	[ 0	locks=0 ]	(	"on"	)
bindings	[ 0	locks=0 ]	(	0	)
groupautobind	[ 0	locks=0 ]	(	"on"	)
groupbindings	[ 0	locks=0 ]	(	0	)
vex_cwdpath	[ 0	locks=0 ]	(	.	)
vex_outputmask	[ 0	locks=0 ]	(	*	)
vex_updatenmls	[ 0	locks=0 ]	(	"off"	)
vex_matchattrib	[ 0	locks=0 ]	(	id	)
vex_inplace	[ 0	locks=0 ]	(	"off"	)
vex_selectiongroup	[ 0	locks=0 ]	(	""	)
vex_precision	[ 0	locks=0 ]	(	auto	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/calcinputsize.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/calcinputsize1.init"
Content-Type: text/plain

type = attribwrangle
matchesdef = 1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/calcinputsize1.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position 4.69751 4.41743
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	OutputGrid 1 1 "input1"
}
inputs
{
0 	OutputGrid 0 1
}
stat
{
  create 1580773086
  modify 1581371327
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/calcinputsize1.parm"
Content-Type: text/plain

{
version 0.8
folder0	[ 0	locks=0 ]	(	0	0	)
group	[ 0	locks=0 ]	(	""	)
grouptype	[ 0	locks=0 ]	(	"guess"	)
class	[ 0	locks=0 ]	(	"detail"	)
vex_numcount	[ 0	locks=0 ]	(	10	)
vex_threadjobsize	[ 0	locks=0 ]	(	1024	)
snippet	[ 0	locks=0 ]	(	"vector point1pos = point(0, \"P\", 0);
point1pos.y = 0;
vector point2pos = point(0, \"P\", 1);
point2pos.y = 0;
float pointdistance = distance(point1pos, point2pos);
vector size = getpointbbox_size(0);
size.x += pointdistance;
size.z += pointdistance;

int gridresolutionX = int(size.x / pointdistance);
int gridresolutionZ = int(size.z / pointdistance);

i@OutputGridResolutionX = gridresolutionX;
i@OutputGridResolutionZ = gridresolutionZ;
"	)
exportlist	[ 0	locks=0 ]	(	*	)
vex_strict	[ 0	locks=0 ]	(	"off"	)
autobind	[ 0	locks=0 ]	(	"on"	)
bindings	[ 0	locks=0 ]	(	0	)
groupautobind	[ 0	locks=0 ]	(	"on"	)
groupbindings	[ 0	locks=0 ]	(	0	)
vex_cwdpath	[ 0	locks=0 ]	(	.	)
vex_outputmask	[ 0	locks=0 ]	(	*	)
vex_updatenmls	[ 0	locks=0 ]	(	"off"	)
vex_matchattrib	[ 0	locks=0 ]	(	id	)
vex_inplace	[ 0	locks=0 ]	(	"off"	)
vex_selectiongroup	[ 0	locks=0 ]	(	""	)
vex_precision	[ 0	locks=0 ]	(	auto	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/calcinputsize1.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribwrangle2.init"
Content-Type: text/plain

type = attribwrangle
matchesdef = 1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribwrangle2.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position -2.19368 1.30456
connectornextid 2
flags =  lock off model off template on footprint off xray off bypass off display on render on highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	python4 2 1 "input1"
}
inputs
{
0 	python4 0 1
}
stat
{
  create 1581371308
  modify 1582576683
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribwrangle2.parm"
Content-Type: text/plain

{
version 0.8
folder0	[ 0	locks=0 ]	(	0	0	)
group	[ 0	locks=0 ]	(	""	)
grouptype	[ 0	locks=0 ]	(	"guess"	)
class	[ 0	locks=0 ]	(	"point"	)
vex_numcount	[ 0	locks=0 ]	(	10	)
vex_threadjobsize	[ 0	locks=0 ]	(	1024	)
snippet	[ 0	locks=0 ]	(	"//p@orient = quaternion(radians(i@rotation), set(0,1,0));
//v@scale = set(i@scaleX,1,1);

matrix3 transform = ident();


prerotate(transform, radians(-i@rotation), set(0,1,0));
//prescale(transform, set(i@scaleX,1,i@scaleX));

3@transform = transform;"	)
exportlist	[ 0	locks=0 ]	(	*	)
vex_strict	[ 0	locks=0 ]	(	"off"	)
autobind	[ 0	locks=0 ]	(	"on"	)
bindings	[ 0	locks=0 ]	(	0	)
groupautobind	[ 0	locks=0 ]	(	"on"	)
groupbindings	[ 0	locks=0 ]	(	0	)
vex_cwdpath	[ 0	locks=0 ]	(	.	)
vex_outputmask	[ 0	locks=0 ]	(	*	)
vex_updatenmls	[ 0	locks=0 ]	(	"off"	)
vex_matchattrib	[ 0	locks=0 ]	(	id	)
vex_inplace	[ 0	locks=0 ]	(	"off"	)
vex_selectiongroup	[ 0	locks=0 ]	(	""	)
vex_precision	[ 0	locks=0 ]	(	auto	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribwrangle2.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/python4.init"
Content-Type: text/plain

type = python
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/python4.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position -2.19068 2.34446
connectornextid 4
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault off exposed on
outputsNamed3
{
2 "output1"
}
inputsNamed3
{
0 	attribwrangle1 1 1 "input1"
1 	IncomingSampleGrid 1 1 "input2"
3 	attribcopy1 2 1 "input3"
}
inputs
{
0 	attribwrangle1 0 1
1 	IncomingSampleGrid 0 1
2 	attribcopy1 0 1
}
stat
{
  create 1579926366
  modify 1583354450
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.322 0.259 0.58 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/python4.parm"
Content-Type: text/plain

{
version 0.8
python	[ 0	locks=0 ]	(	"from collections import Counter
from itertools import chain
import numpy as np

# Geo I/O
node = hou.pwd()
inputs = node.inputs()
geo = node.geometry()
geo.addAttrib(hou.attribType.Point, \"rotation\", 0)
geo.addAttrib(hou.attribType.Point, \"scaleX\", 1)
OutputPoints = geo.points()
HDANode = node.parent()


# User Parms
Seed = HDANode.parm(\"iSeed\").evalAsInt()
N = HDANode.parm(\"iPatternSearchSize\").evalAsInt()
MaxNumberContradictionTries = HDANode.parm(\"iNumSolveAttempts\").evalAsInt()
UseInputPatternFrequency = HDANode.parm(\"bObservedPatternFreq\").evalAsInt()
TileAroundBounds = True if HDANode.parm(\"bTileableOutput\").evalAsInt() == 1 else False
PeriodicInput = True if HDANode.parm(\"bPeriodicInputPatterns\").evalAsInt() == 1 else False
RespectUserConstraints = True if HDANode.parm(\"bUserConstraints\").evalAsInt() == 1 else False
AddRotations = True if HDANode.parm(\"bGenerateRotations\").evalAsInt() == 1 else False
InputGridSize = (inputs[2].geometry().attribValue(\"SampleGridResolutionX\"), inputs[2].geometry().attribValue(\"SampleGridResolutionZ\"))
if HDANode.parm(\"bAutomaticInputSizeDetection\").evalAsInt() == 0:
    InputGridSize = HDANode.parmTuple(\"i2SampleGridSize\").eval()

OutputGridSize = (inputs[2].geometry().attribValue(\"OutputGridResolutionX\"), inputs[2].geometry().attribValue(\"OutputGridResolutionZ\"))
if HDANode.parm(\"bAutomaticOutputSizeDetection\").evalAsInt() == 0:
    OutputGridSize = HDANode.parmTuple(\"i2OutputGridSize\").eval()

# print \"Sample\", InputGridSize
#print \"Output\", OutputGridSize

SolveStartingPointIndex = None
if HDANode.parm(\"bStartingPoint\").evalAsInt() == 1:
    SolveStartingPointIndex = HDANode.parm(\"iStartingPoint\").evalAsInt()


# Internal Parms
PatternFrequencies = None
Patterns = None
PatternsTransforms = None #[\"rot\", \"flipX\", \"flipY\"]
NumberOfUniquePatterns = None
NbrDirections = ((-1, 0), (1, 0), (0, -1), (0, 1))
OutputGrid = {}
EntropyGrid = {}
AllowedPatternAdjacencies = {}
InputSampleAttributes = []
UserConstraintAttributes = []



def ReadInputAttributes(points):
    AttributeList = []

    for point in points:
        AttributeList.append(point.attribValue(\"name\"))
    return AttributeList


# Here we will take the input grid, extract its values (name attribute), and cut it up into NxN size patterns
def CreatePatternsFromInput():
    global PatternFrequencies, Patterns, PatternsTransforms, NumberOfUniquePatterns

    # Kernel to store data in
    SearchKernel = tuple(tuple(i + n*InputGridSize[0] for i in xrange(N)) for n in xrange(N))

    AllTempPatterns = []
    AllTempPatternsTransforms = []

    if PeriodicInput:
        Offset = 0
    else:
        Offset = (N-1)

    # Loop over grid
    for y in xrange(InputGridSize[1] - Offset):
        for x in xrange(InputGridSize[0] - Offset):
 
            MatrixAsList = []
            for item in SearchKernel:
                Tmp = []
                for subitems in item:
                    listindex = ((x+subitems) %InputGridSize[0]) + ((( item[0] + InputGridSize[0] * y) / InputGridSize[0]) % InputGridSize[1]) * InputGridSize[0]
                    Tmp.append(InputSampleAttributes[listindex])
                    
                # This is where variations would take place

                MatrixAsList.append(tuple(Tmp))

            TempPattern = tuple(MatrixAsList)

            if not AddRotations:
                AllTempPatterns.append(TempPattern)
                AllTempPatternsTransforms.append([0, 1, 1])
            else:
                for x in xrange(4):
                    TempPattern = zip(*TempPattern[::-1])
                    AllTempPatterns.append(TempPattern)
                    AllTempPatternsTransforms.append([(x+1)*90, 1, 1])
                    # Maybe add horizontal flip too??
                    # AllTempPatterns.append([a[::-1] for a in TempPattern]) # Flip X
                    # AllTempPatternsTransforms.append([(x+1)*90, -1, 1])


    AllTempPatterns = [tuple(chain.from_iterable(p)) for p in AllTempPatterns]

    Patterns = []
    PatternsTransforms = []
    PatternFrequencies = []

    for i, pattern in enumerate(AllTempPatterns):
        if pattern not in Patterns:
            Patterns.append(pattern)
            PatternFrequencies.append(1)
            PatternsTransforms.append(AllTempPatternsTransforms[i])
        else:
            index = Patterns.index(pattern)
            PatternFrequencies[index] += 1

    NumberOfUniquePatterns = len(PatternFrequencies)
    #print NumberOfUniquePatterns
    

# Here we create a list that will be used as our output grid. (Used for solving in)
def InitializeGrid():
    global OutputGrid

    for x in xrange(OutputGridSize[0]*OutputGridSize[1]):
        OutputGrid[x] = set(range(NumberOfUniquePatterns))


# Here we create grid that matches the output grid, but we store entropy values instead. (Entropy = Number of remaining legal patterns)
def InitializeEntropyGrid():
    global EntropyGrid, SolveStartingPointIndex

    for x in xrange(OutputGridSize[0]*OutputGridSize[1]):
        EntropyGrid[x] = NumberOfUniquePatterns

    # Pick starting point for solve. (Random if not specified)
    if SolveStartingPointIndex == None:
        #SolveStartingPointIndex = np.random.randint(NumberOfUniquePatterns)
        #### LOOK HERE
        SolveStartingPointIndex = np.random.randint(len(EntropyGrid.keys()))

    EntropyGrid[SolveStartingPointIndex] = NumberOfUniquePatterns-1


def CalculateAdjacencies():
    global AllowedPatternAdjacencies

    # If PatternIndex = 10 has been observed to be to the left of of PatternIndex = 15 in the InputGrid:
    # AllowedPatternAdjacencies[PatternIndex=15][0].add(PatternIndex=10)
    # Directions: 0 = left, 1 = right, 2 = up, 3 = down
    # OUTPUT EXAMPLE PatternIndex = 15 --> (LEFT: set([65, 36, 69, 44, 87, 56, 29]), RIGHT: set([8]), UP: set([32, 64, 10, 12, 14, 83, 21]), DOWN: set([15]))


    # Initialize empty AllowedPatternAdjacencies
    for x in xrange(NumberOfUniquePatterns):
        AllowedPatternAdjacencies[x] = tuple(set() for direction in xrange(len(NbrDirections)))

    # Comparing patterns to each other
    for PatternIndex1 in xrange(NumberOfUniquePatterns):
        for PatternIndex2 in xrange(NumberOfUniquePatterns):

            Pattern1BoundaryColumns = [n for i, n in enumerate(Patterns[PatternIndex1]) if i%N!=(N-1)]
            Pattern2BoundaryColumns = [n for i, n in enumerate(Patterns[PatternIndex2]) if i%N!=0]

            # Compare Columns compatability
            if Pattern1BoundaryColumns == Pattern2BoundaryColumns:
                AllowedPatternAdjacencies[PatternIndex1][0].add(PatternIndex2)
                AllowedPatternAdjacencies[PatternIndex2][1].add(PatternIndex1)

            Pattern1BoundaryRows = Patterns[PatternIndex1][:(N*N)-N]
            Pattern2BoundaryRows = Patterns[PatternIndex2][N:]

            if Pattern1BoundaryRows == Pattern2BoundaryRows:
                AllowedPatternAdjacencies[PatternIndex1][2].add(PatternIndex2)
                AllowedPatternAdjacencies[PatternIndex2][3].add(PatternIndex1)


# Find the list entry in the entropy grid with the lowest value
def GetLowestEntropyCell():
    return min(EntropyGrid, key = EntropyGrid.get)


# Assign a random allowed PatternIndex to given cell. This can either use frequency of found patterns as a weighted random or not depending on user parm
def GetRandomAllowedPatternIndexFromCell(cell):
    if UseInputPatternFrequency == 1:
        return np.random.choice([PatternIndex for PatternIndex in OutputGrid[cell] for i in xrange(PatternFrequencies[PatternIndex])])
    else:
        return np.random.choice([PatternIndex for PatternIndex in OutputGrid[cell]])


# Assign given cell a chosen PatternIndex, and delete cell from EntropyGrid (Cell has collapsed)
def AssignPatternToCell(cell, PatternIndex):
    global OutputGrid, EntropyGrid
    OutputGrid[cell] = {PatternIndex}
    del EntropyGrid[cell]


# This propagates all the cells that should have been affected from the just-collapsed cell
def PropagateGridCells(cell):
    global EntropyGrid, OutputGrid

    # We are using a stack to add newly found to-be-updated cells to
    ToUpdateStack = {cell}
    while len(ToUpdateStack) != 0:
        CellIndex = ToUpdateStack.pop() 

        # loop through neighbor cells of currently propagated cell
        for direction, transform in enumerate(NbrDirections):
            
            NeighborIndexIsValid = True

            x = (CellIndex%OutputGridSize[0] + transform[0])%OutputGridSize[0]
            y = (CellIndex/OutputGridSize[0] + transform[1])%OutputGridSize[1]
            NeighborCellIndex = x + y * OutputGridSize[0] # index of negihboring cell


            # If the user does not want the WFC solve to create a tiling output, we just state that the found neighbor cell is invalid and don't propagate it
            if not TileAroundBounds:
                xiswrapping = abs(NeighborCellIndex % OutputGridSize[0] - CellIndex % OutputGridSize[0]) > 1
                yiswrapping = abs(NeighborCellIndex / OutputGridSize[1] - CellIndex / OutputGridSize[1]) > 1

                if xiswrapping or yiswrapping:
                    NeighborIndexIsValid = False
                

            # Cell has not yet been collapsed yet
            if NeighborCellIndex in EntropyGrid and NeighborIndexIsValid:   

                # These are all the allowed patterns for the direction of the checked neighbor cell
                PatternIndicesInCell = {n for PatternIndex in OutputGrid[CellIndex] for n in AllowedPatternAdjacencies[PatternIndex][direction]}

                # These are all the patterns the neighbor allows itself
                PatternIndicesInNeighborCell = OutputGrid[NeighborCellIndex]

                # Make sure we need to update the cell by checking if the currently PatternIndicesInCell patterns for the neighbor cells are already fully contained
                # in the now reduced set of patterns
                if not PatternIndicesInNeighborCell.issubset(PatternIndicesInCell):

                    SharedCellAndNeighborPatternIndices = set([x for x in PatternIndicesInCell if x in PatternIndicesInNeighborCell])

                    if len(SharedCellAndNeighborPatternIndices) == 0:
                        return False, 1

                    OutputGrid[NeighborCellIndex] = SharedCellAndNeighborPatternIndices
                    EntropyGrid[NeighborCellIndex] = len(OutputGrid[NeighborCellIndex])
                    ToUpdateStack.add(NeighborCellIndex)

    return True, 0


# This is a utility function that chops a given list into lists of size N
def CutListInChunksOfSize(l, n):
    n = max(1, n)
    return (l[i:i+n] for i in xrange(0, len(l), n)) 


# This is a utility function that prints the entropy grid in a userfriendly format
def PrintEntropyGridStatus():
    PrintEntropyGrid = []
    for i in xrange(OutputGridSize[0] * OutputGridSize[1]):
        Value = 1
        if EntropyGrid.has_key(i):
            Value = EntropyGrid[i]
        PrintEntropyGrid.append(Value)

    print list(CutListInChunksOfSize(PrintEntropyGrid, OutputGridSize[0]))


# This finds and assigns the picked PatternIndex to the output grid as attributes
def AssignWaveToOutputGrid():
    for x in OutputGrid.keys():
        val = next(iter(OutputGrid[x])) 
        OutputPoints[x].setAttribValue(\"name\", Patterns[val][0])
        OutputPoints[x].setAttribValue(\"rotation\", PatternsTransforms[val][0])
        OutputPoints[x].setAttribValue(\"scaleX\", PatternsTransforms[val][1])



# This function handles assigning user constraints based on attached attribute values to the output grid
def ForceUserConstraints():
    for cellindex, cellvalue in enumerate(UserConstraintAttributes):
        if cellvalue != \"WFC_Initialize\" and cellvalue in UserConstraintAttributes:
            AllowedIndices = [x for x in xrange(len(Patterns)) if cellvalue == Patterns[x][0]]
            #print len(AllowedIndices)

            PickedIndex = np.random.choice([PatternIndex for PatternIndex in AllowedIndices])
            AssignPatternToCell(cellindex, PickedIndex)
            Running, Error = PropagateGridCells(cellindex)
            if Error == 1:
                return False
    return True


# This runs the actual WFC solve
def RunWFCSolve(): 
    Running = True
    while Running:

        # Find the cell with the lowest entropy value, and assign a random valid PatternIndex
        LowestEntropyCell = GetLowestEntropyCell()
        PatternIndexForCell = GetRandomAllowedPatternIndexFromCell(LowestEntropyCell)
        AssignPatternToCell(LowestEntropyCell, PatternIndexForCell)

        # Propagate the OutputGrid after collapsing the LowestEntropyCell
        Running, Error = PropagateGridCells(LowestEntropyCell)

        # Check if all cells in the OutputGrid have collapsed yet (done solving)
        if len(EntropyGrid.keys()) == 0:
            Running = False

    # Check if we have ran into an error. (contradiction while propagating)
    if Error == 1:
        return False
    else:    
        return True


#### START THE WFC ALGORITHM SOLVE BELOW
##################################
InputSampleAttributes = ReadInputAttributes(inputs[1].geometry().points())
UserConstraintAttributes = ReadInputAttributes(OutputPoints)


with hou.InterruptableOperation(\"Solving WFC\", open_interrupt_dialog=True) as Operation:

    # try:
    # # The WFC solve has been wrapped in a loop that tries solving at different seed values in case a contradiction has been found
    for solveattempt in xrange(MaxNumberContradictionTries): 

        # Set the seed for our random picking of values
        np.random.seed(Seed+solveattempt*100)
        Operation.updateProgress(float(solveattempt) / float(MaxNumberContradictionTries))

        # Initialize WFC process
        CreatePatternsFromInput()
        InitializeGrid()
        InitializeEntropyGrid()
        CalculateAdjacencies()
        
        if RespectUserConstraints:
            Success = ForceUserConstraints()
        else: Success = True

        if Success:
            # Run the WFC solve itself
            Success = RunWFCSolve()

        # Assign the outputvalues
        if Success == True:
            AssignWaveToOutputGrid()
            break

        # If we have exceeded the number of retries for the solve, we will throw an error to tell the user no solution has been found
        if solveattempt == MaxNumberContradictionTries-1 and Success == False:
            print \"Surpassed max number of contradiction retries.... Aborting\"
    # except:
    #     print \"Something went wrong\"


# TODO:
# 1. Allow certain pieces to only instantiate once"	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/python4.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"18.0.391"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/IncomingSampleGrid.init"
Content-Type: text/plain

type = null
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/IncomingSampleGrid.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position 1.89114 6.28304
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	(1) "" 1 "input1"
}
inputs
{
0 	(1) 0 1
}
stat
{
  create 1580018971
  modify 1580774612
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.6 0.7 0.77 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/IncomingSampleGrid.parm"
Content-Type: text/plain

{
version 0.8
copyinput	[ 0	locks=0 ]	(	"on"	)
cacheinput	[ 0	locks=0 ]	(	"off"	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/IncomingSampleGrid.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"18.0.391"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/OutputGrid.init"
Content-Type: text/plain

type = null
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/OutputGrid.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position -2.19068 6.28304
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	(0) "" 1 "input1"
}
inputs
{
0 	(0) 0 1
}
stat
{
  create 1580018971
  modify 1580774609
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.6 0.7 0.77 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/OutputGrid.parm"
Content-Type: text/plain

{
version 0.8
copyinput	[ 0	locks=0 ]	(	"on"	)
cacheinput	[ 0	locks=0 ]	(	"off"	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/OutputGrid.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"18.0.391"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.init"
Content-Type: text/plain

type = output
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position -2.19068 -0.73334
connectornextid 1
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
}
inputsNamed3
{
0 	attribdelete1 1 1 "input1"
}
inputs
{
0 	attribdelete1 0 1
}
stat
{
  create 1580019001
  modify 1582576683
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.parm"
Content-Type: text/plain

{
version 0.8
outputidx	[ 0	locks=0 ]	(	0	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"18.0.391"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribcopy1.init"
Content-Type: text/plain

type = attribcopy
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribcopy1.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position 1.74741 3.34674
connectornextid 3
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
2 "output1"
}
inputsNamed3
{
0 	calcinputsize 1 1 "input1"
1 	calcinputsize1 1 1 "input2"
}
inputs
{
0 	calcinputsize 0 1
1 	calcinputsize1 0 1
}
stat
{
  create 1580774552
  modify 1581484289
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribcopy1.parm"
Content-Type: text/plain

{
version 0.8
srcgroup	[ 0	locks=0 ]	(	""	)
srcgrouptype	[ 0	locks=0 ]	(	"points"	)
destgroup	[ 0	locks=0 ]	(	""	)
destgrouptype	[ 0	locks=0 ]	(	"points"	)
matchbyattribute	[ 0	locks=0 ]	(	"off"	)
attributetomatch	[ 0	locks=0 ]	(	piece	)
attrib	[ 0	locks=0 ]	(	"otherattrib"	)
attribname	[ 0	locks=0 ]	(	"OutputGridResolutionX OutputGridResolutionZ"	)
copyp	[ 0	locks=0 ]	(	"on"	)
usenewname	[ 0	locks=0 ]	(	"off"	)
newname	[ 0	locks=0 ]	(	""	)
class	[ 0	locks=0 ]	(	"guess"	)
copyvariable	[ 0	locks=0 ]	(	"on"	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribcopy1.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"18.0.391"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribdelete1.init"
Content-Type: text/plain

type = attribdelete
matchesdef = 1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribdelete1.def"
Content-Type: text/plain

sopflags sopflags = 
comment ""
position -2.19413 0.26666
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress on colordefault on exposed on
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	attribwrangle2 1 1 "input1"
}
inputs
{
0 	attribwrangle2 0 1
}
stat
{
  create 1581377125
  modify 1582576683
  author Paul_Ambrosiussen@LAPTOP-P8R7FBPF
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribdelete1.parm"
Content-Type: text/plain

{
version 0.8
ptdel	[ 0	locks=0 ]	(	"scaleX rotation"	)
vtxdel	[ 0	locks=0 ]	(	""	)
primdel	[ 0	locks=0 ]	(	""	)
dtldel	[ 0	locks=0 ]	(	varmap	)
updatevar	[ 0	locks=0 ]	(	"on"	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/attribdelete1.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.order"
Content-Type: text/plain

10
python4
IncomingSampleGrid
OutputGrid
output0
attribwrangle1
calcinputsize
calcinputsize1
attribcopy1
attribwrangle2
attribdelete1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.net"
Content-Type: text/plain

1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY--
