from datetime import datetime
from time import sleep
from labsopui import reset_viewport
from labutils import manage_ocio


# Render Intermediate Images


def setUpOCIO():

    if hou.getenv('OCIO') is not None:
        return

    manage_ocio(destination="$HOUDINI_USER_PREF_DIR/packages/Labs_OpenColorIO.json", install=1)

    message = \
        "The $OCIO environment variable has been set to a minimal version of OCIO ACES 1.2 shipped with SideFX Labs. \n" \
        "This changes the viewport default color space to ACES sRGB. " \
        "Unhide Color Correction Bar at the bottom of a viewport to verify or switch color spaces. \n" \
        "Learn more about ACES at https://www.sidefx.com/docs/houdini/pyro/shading.html. \n \n" \
        "Please restart Houdini for the changes to take effect."

    print (message)

    return



def checkInputs(node):

    try:
        node.node(node.path() + '/empty/error_reports/msg_input').cook(True)

    except hou.OperationFailed:
        return None

    cam = node.node(node.evalParm('camerapath'))

    if type(cam) is not hou.ObjNode:
        return None

    elif cam.type().name() != 'cam':
        return None

    else:

        if cam.evalParm('near') < node.evalParm('nearcliplimit'):
            cam.setParms({'near': node.evalParm('nearcliplimit')})

        main_vol_path = node.evalParm('bakevolpath1')
        main_geometry = node.node(main_vol_path)

        if type(main_geometry) is hou.SopNode:

            if main_geometry.type().name() == 'pyrobakevolume':
                    return main_geometry

        main_non_vol_path = node.evalParm('nonvolpath')
        main_geometry = node.node(main_non_vol_path)

        if type(main_geometry) is hou.SopNode:
                return main_geometry

    return None



def pinSelectionFollowingTabs(node):

    tabs = [pane_tab for pane_tab in hou.ui.paneTabs() if isinstance(pane_tab, hou.PathBasedPaneTab)]
    selection_following_tabs = []
    selection_following_tab_nodes = []

    for tab in tabs:

        if tab.type() != hou.paneTabType.SceneViewer:

            if tab.linkGroup() == hou.paneLinkType.FollowSelection:
                tab.setPin(True)
                selection_following_tabs.append(tab)
                selection_following_tab_nodes.append(tab.currentNode())

    return {'free_tabs': selection_following_tabs, 'free_tab_nodes': selection_following_tab_nodes}



# Points all existing Scene Viewers to an embedded empty OBJ network and then resets them to clear the GPU memory.
# Returns a dictionary of Scene Viewer data, which are needed to restore these Scene Viewers after rendering. 
def clearExistingSceneViewers(node):

    tab_data = pinSelectionFollowingTabs(node)
    scene_viewers = [pane_tab for pane_tab in hou.ui.paneTabs() if pane_tab.type() == hou.paneTabType.SceneViewer]
    scene_viewer_nodes = []
    link_groups = []

    for scene_viewer in scene_viewers:

        scene_viewer_nodes.append(scene_viewer.currentNode())
        link_groups.append(scene_viewer.linkGroup())
        scene_viewer.setPin(True)
        scene_viewer.setCurrentNode(node.node(node.path() + '/empty/clear_scene_viewer_gpu_mem'))
        reset_viewport.resetSceneViewer(scene_viewer)

    return {'scene_viewer_nodes': scene_viewer_nodes, 'link_groups': link_groups, 'free_tabs': tab_data['free_tabs'], 'free_tab_nodes': tab_data['free_tab_nodes']}



def restoreExistingSceneViewers(node, scene_viewer_data):

    scene_viewers = [pane_tab for pane_tab in hou.ui.paneTabs() if pane_tab.type() == hou.paneTabType.SceneViewer]

    for i in range(len(scene_viewer_data['scene_viewer_nodes'])):

        link_group = scene_viewer_data['link_groups'][i]

        if link_group is not None:
            scene_viewers[i].setLinkGroup(link_group)

        scene_viewer_node = scene_viewer_data['scene_viewer_nodes'][i]

        try:

            if isinstance(scene_viewer_node, hou.Node):
    
                path = scene_viewer_node.path()
    
                if path != '/obj' and path != '':
                    scene_viewers[i].setCurrentNode(scene_viewer_node)
    
            else:
    
                scene_viewers[i].setCurrentNode(node.node(node.evalParm('camerapath')))

        except (hou.OperationFailed, hou.OperationInterrupted):

            # Sometimes irrelevant exceptions are raised even though the operation has succeeded.
            # It's not worth raising those exceptions to confuse the users.
            pass  

    for i in range(len(scene_viewer_data['free_tabs'])):

        try:
            tab = scene_viewer_data['free_tabs'][i]
            tab.setPin(False)
            tab.setCurrentNode(scene_viewer_data['free_tab_nodes'][i])
        except:
            # Sometimes irrelevant exceptions are raised even though the operation has succeeded.
            # It's not worth raising those exceptions to confuse the users.
            pass

    return



def closeSceneViewer(scene_viewer, scene_viewer_node = None):

    try:

        if type(scene_viewer) is hou.SceneViewer:
            scene_viewer.close()

    except:

        # Sometimes irrelevant exceptions are raised even though the operation has succeeded.
        # It's not worth raising those exceptions to confuse the users.
        pass

    try:

        if isinstance(scene_viewer_node, hou.Node):
            scene_viewer_node.destroy()

    except:

        # Sometimes irrelevant exceptions are raised even though the operation has succeeded.
        # It's not worth raising those exceptions to confuse the users.
        pass

    return



def mergeRenderGeometries(node, main_geometry, non_emissive_pass = False):

    if main_geometry is None:
        return None 

    # Attempts to disable any Template flags on any sibling nodes.
    try:

        for sibling in main_geometry.parent().children():

            sibling.setGenericFlag(hou.nodeFlag.Template, False)
            sibling.setGenericFlag(hou.nodeFlag.Footprint, False)

    except Exception as exc:
        
        # Prints the exception but the rest of the code should execute regardless
        print (type(exc).__name__, exc)

    merged_geos = main_geometry.parent().createNode('object_merge', 'merge_render_geos')
    merged_geos.setParms({'numobj': 6, 'xformtype': 1})
    count = 0

    # Merges volumes
    for i in range(1, 6):

        idx = str(i)
        merged_geos.parm('enable' + idx).set(0)
        geo_path = node.evalParm('bakevolpath' + idx)
        pyro_bake_volume = node.node(geo_path)

        if type(pyro_bake_volume) is hou.SopNode:

            if pyro_bake_volume.type().name() == 'pyrobakevolume':

                geo_path = pyro_bake_volume.path()  # This returns the full path
                geo_path += '/VISUALIZER'
                merged_geos.parm('objpath' + idx).set(geo_path)
                merged_geos.parm('enable' + idx).set(1)
                count += 2

        # Skips merging the secondary paths if the main path is invalid
        if i == 1 and count == 0:
            break

    # Merges non-volumes

    merged_geos.parm('enable6').set(0)

    emissive_property = node.evalParm('nonvolemissive')

    geo_path = ''

    if not non_emissive_pass:
        # Non-volumetric Final Color:

        geo_path = node.evalParm('nonvolpath')

    elif node.evalParm('nonvolpath') != '':
        # Non-volumetric Non-emissive Color:

        if emissive_property == 0:
            # Not Emissive:
            geo_path = node.evalParm('nonvolpath')

        elif emissive_property == 1:
            # Partially Emissive:
            geo_path = node.evalParm('nonvolncpath')

        elif emissive_property == 2:
            # Fully Emissive:
            geo_path = ''
        
    non_vol = node.node(geo_path)

    # If 'geo_path' doesn't point to anything valid, 
    # non-volumes simply won't be merged in.

    if type(non_vol) is hou.SopNode:

        geo_path = non_vol.path()  # This returns the full path
        merged_geos.parm('objpath6').set(geo_path)
        merged_geos.parm('enable6').set(1)
        count += 1

    if count == 0:

        merged_geos.destroy()
        merged_geos = None
        print ('There is nothing valid to render.')

    return merged_geos



def setCommonSceneViewerSettings(node, scene_viewer_node, padding = 0):

    target_res = (node.evalParm('frameresx'), node.evalParm('frameresy'))
    pos = (node.evalParm('viewerposx'), node.evalParm('viewerposy'))
    scene_viewer = hou.ui.curDesktop().createFloatingPaneTab(hou.paneTabType.SceneViewer, pos, target_res, None, True)
    scene_viewer.showOperationBar(True)
    scene_viewer.showDisplayOptionsBar(True)
    res = scene_viewer.curViewport().resolutionInPixels()
    res = (target_res[0] * 2 - res[0], target_res[1] * 2 - res[1] + padding * 2)
    scene_viewer.close()
    
    scene_viewer = hou.ui.curDesktop().createFloatingPaneTab(hou.paneTabType.SceneViewer, pos, res, None, True)
    scene_viewer.setPin(True)
    scene_viewer.setCurrentNode(scene_viewer_node)
    scene_viewer.showOperationBar(True)
    scene_viewer.showDisplayOptionsBar(True)
    scene_viewer.referencePlane().setIsVisible(False)

    return scene_viewer



def setCommonViewportSettings(node, scene_viewer, render_type):

    viewport = scene_viewer.curViewport()
    viewport.setCamera(node.node(node.evalParm('camerapath')).path())
    
    viewport_settings = viewport.settings()

    # Rendering

    if render_type == 'lit':

        viewport_settings.particlePointSize(node.evalParm('pointsize_lit'))
        viewport_settings.wireWidth(node.evalParm('wirewidth_lit'))
        viewport_settings.setShadowMapSize(node.evalParm('shadowmapres'))
        viewport_settings.setShadowMapSizeFromLight(False)
        viewport_settings.showSpecular(node.evalParm('enablespecincols'))
        viewport_settings.showEmission(True)

        if node.evalParm('lighting') == 0:

            viewport_settings.setLighting(hou.viewportLighting.Off)
            viewport_settings.setShadowQuality(hou.viewportShadowQuality.Point)

        elif node.evalParm('lighting') == 1:

            viewport_settings.setLighting(hou.viewportLighting.Headlight)
            viewport_settings.setShadowQuality(hou.viewportShadowQuality.Point)
    
        elif node.evalParm('lighting') == 2:

            viewport_settings.setLighting(hou.viewportLighting.Normal)
            viewport_settings.setShadowQuality(hou.viewportShadowQuality.Point)
    
        elif node.evalParm('lighting') == 3:

            viewport_settings.setLighting(hou.viewportLighting.HighQuality)
            viewport_settings.setShadowQuality(hou.viewportShadowQuality.Point)
    
        elif node.evalParm('lighting') == 4:

            viewport_settings.setLighting(hou.viewportLighting.HighQualityWithShadows)
            viewport_settings.setShadowQuality(hou.viewportShadowQuality.PointAA)
     
        elif node.evalParm('lighting') == 5:

            viewport_settings.setLighting(hou.viewportLighting.HighQualityWithShadows)
            viewport_settings.setShadowQuality(hou.viewportShadowQuality.AreaAA)

    elif render_type == 'unlit':

        viewport_settings.particlePointSize(node.evalParm('pointsize_unlit'))
        viewport_settings.wireWidth(node.evalParm('wirewidth_unlit'))
        viewport_settings.setShadowMapSize(16)
        viewport_settings.setShadowMapSizeFromLight(False)
        viewport_settings.showSpecular(False)
        viewport_settings.showEmission(False)
        viewport_settings.setLighting(hou.viewportLighting.Off)

    viewport_settings.setSceneAntialias(pow(2, node.evalParm('aasamples')))
    viewport_settings.setTextureMaxMemory(node.evalParm('singletexmemlimit'))
    viewport_settings.setTransparencyQuality(hou.viewportTransparency.High)
    viewport_settings.setHdrRendering(True)
    viewport_settings.setTextureAutoReduce(False)
    viewport_settings.setTextureAutoReduce2D(False)
    viewport_settings.setTextureAutoReduce3D(False)
    viewport_settings.setTexture2DSettingsFor3D(False)

    # Volume quality

    max_res_3d_level = node.evalParm('texlimit3dlvl')

    if max_res_3d_level > 0:
        max_res_3d = (max_res_3d_level, max_res_3d_level, max_res_3d_level)

    else:
        max_res_3d = (node.evalParm('texlimit3dx'), node.evalParm('texlimit3dy'), node.evalParm('texlimit3dz'))

    viewport_settings.setTextureMaxRes3D(max_res_3d)
    viewport_settings.setTextureResLimit3D(True)
    viewport_settings.setTextureBitDepthLimit3D(hou.viewportTextureDepth.HDR16)
    viewport_settings.volumeBSplines(hou.viewportVolumeBSplines.NonInteractive)
    if node.evalParm('volquality') == 0:
        viewport_settings.volumeQuality(hou.viewportVolumeQuality.Normal)
    elif node.evalParm('volquality') == 1:
        viewport_settings.volumeQuality(hou.viewportVolumeQuality.High)
    
    # Viewport displays

    scene_viewer_name = hou.ui.curDesktop().name() + '.' + scene_viewer.name() + '.world'
    hou.hscript('vieweroption -a {0} {1}'.format(0, scene_viewer_name))
    viewport_settings.setDisplayEnvironmentBackgroundImage(False)
    viewport_settings.setColorScheme(hou.viewportColorScheme.Dark)
    viewport_settings.displaySet(hou.displaySetType.DisplayModel).setShadedMode(hou.glShadingType.Smooth)
    viewport_settings.displaySet(hou.displaySetType.SceneObject).setShadedMode(hou.glShadingType.Smooth)
    viewport_settings.displaySet(hou.displaySetType.DisplayModel).useUVMap(False)
    viewport_settings.displaySet(hou.displaySetType.SceneObject).useUVMap(False)
    viewport_settings.enableGuide(hou.viewportGuide.FloatingGnomon, False)
    viewport_settings.enableGuide(hou.viewportGuide.ObjectSelection, False)
    viewport_settings.showsName(False)
    viewport_settings.showsCameraName(False)

    return {'viewport': viewport, 'settings': viewport_settings}



def setCommonFlipbookSettings(node, scene_viewer):

    fb_settings = scene_viewer.flipbookSettings()
    fb_settings.frameRange((node.evalParm('f1'), node.evalParm('f2')))
    fb_settings.frameIncrement(node.evalParm('f3'))
    fb_settings.resolution((node.evalParm('frameresx'), node.evalParm('frameresy')))
    fb_settings.sheetSize((node.evalParm('gridsizex'), node.evalParm('gridsizey')))
    fb_settings.outputToMPlay(node.evalParm('outputtomplay'))
    fb_settings.appendFramesToCurrent(node.evalParm('appendrenders'))

    fb_settings.useSheetSize(True)
    fb_settings.overrideLUT(False)
    fb_settings.overrideGamma(False)
    fb_settings.renderAllViewports(False)
    fb_settings.visibleTypes(hou.flipbookObjectType.GeoOnly)
    fb_settings.antialias(hou.flipbookAntialias.UseViewportSetting)

    return fb_settings


def updateTimeStamp(node, parm_name):

    parm = node.parm(parm_name)
    
    if node.evalParm('enabletimestamps') and parm is not None:

        try:

            now = datetime.now()
            time_stamp = now.strftime('%d %b %Y %I:%M %p')
            parm.set(time_stamp)

        except:

            pass

    return



def setOCIODisplayViewSafe(display, view, viewer, viewport_settings=None):

    try:

        viewer.setOCIODisplayView(display, view)

    except hou.OperationFailed as exc:

        viewer.setUsingOCIO(False)

        if type(viewport_settings) is hou.GeometryViewportSettings:
            viewport_settings.setSceneGamma(1.0)

        elif type(viewer) is hou.CompositorViewer:
            hou.hscript('colorsettings -g 1.0 -c')

        print (exc)
        print ("Falling back to using linear color space.")

    except Exception as exc2:

        print (exc2)
        raise exc2

    return



def setColorSpace(node, color_space, scene_viewer, viewport_settings, fb_settings):

    render_in_linear = color_space < 2
    ocio_env = hou.getenv('OCIO')

    if render_in_linear or ocio_env is None:

        scene_viewer.setUsingOCIO(False)

        if render_in_linear:
            viewport_settings.setSceneGamma(1.0)

        else:
            print ("OCIO ACES has not been set up.")
            raise hou.OperationFailed

    else:

        scene_viewer.setUsingOCIO(True)

        if '/misc/labs_ocio/aces_config.ocio' in ocio_env:
            # Labs Minimal OCIO ACES:

            if color_space == 2:
                setOCIODisplayViewSafe('sRGB', 'ACES', scene_viewer, viewport_settings)

            elif color_space == 3:
                setOCIODisplayViewSafe('Rec.709', 'ACES', scene_viewer, viewport_settings)

            elif color_space == 4:
                setOCIODisplayViewSafe('Rec.2020', 'ACES', scene_viewer, viewport_settings)

            elif color_space == 5:
                setOCIODisplayViewSafe('DCI-P3 D65', 'ACES', scene_viewer, viewport_settings)

        else:
            # Official OCIO ACES:

            if color_space == 2:
                setOCIODisplayViewSafe('ACES', 'sRGB', scene_viewer, viewport_settings)

            elif color_space == 3:
                setOCIODisplayViewSafe('ACES', 'Rec.709', scene_viewer, viewport_settings)

            elif color_space == 4:
                setOCIODisplayViewSafe('ACES', 'Rec.2020', scene_viewer, viewport_settings)

            elif color_space == 5:
                setOCIODisplayViewSafe('ACES', 'P3-DCI D65 simulation', scene_viewer, viewport_settings)

    fb_settings.beautyPassOnly(render_in_linear)

    return



# Render Intermediate Images


def renderFinalColor(node, single_pass = True, main_geometry = None):

    success = False

    if node.evalParm('renderer_fc') == 0: 
        return True

    # Ensures this variable exists so the 'finally' clause can always execute
    scene_viewer = None

    if single_pass:
        
        main_geometry = checkInputs(node)

        if main_geometry is None:
            return False

        existing_scene_viewer_data = clearExistingSceneViewers(node)

    try:

        # Start of This Pass ...

        scene_viewer_node = mergeRenderGeometries(node, main_geometry)
    
        if scene_viewer_node is None:
            return False

        scene_viewer_node.setGenericFlag(hou.nodeFlag.Display, True)
        scene_viewer_node.setGenericFlag(hou.nodeFlag.Render, True)

        scene_viewer = setCommonSceneViewerSettings(node, scene_viewer_node, node.evalParm('viewportpadding'))
        viewport_data = setCommonViewportSettings(node, scene_viewer, 'lit')
        fb_settings = setCommonFlipbookSettings(node, scene_viewer)
    
        # Pass-specific viewport overrides
        # None
    
        setColorSpace(node, node.evalParm('colspace'), scene_viewer, viewport_data['settings'], fb_settings)

        # Starts the render
        fb_settings.output(node.evalParm('interdir') + 'FC.pic.gz')
        sleep(node.evalParm('warmuptime'))
        scene_viewer.flipbook(viewport_data['viewport'], fb_settings)
        updateTimeStamp(node, 'lb_timestamp_fc')

        success = True
    
    except Exception as exc:

        raise exc

    finally:

        closeSceneViewer(scene_viewer, scene_viewer_node)

        if success and node.evalParm('bakevolpath1') != '' and node.evalParm('nonvolpath') != '':
            success = renderSeparateAlphas(node, False)

        # ... End of This Pass
        
        if single_pass:
            restoreExistingSceneViewers(node, existing_scene_viewer_data)
    
    return success



def renderSeparateAlphas(node, single_pass = True):

    success = False

    if node.evalParm('renderer_sa') == 0 and node.evalParm('explicitsacontrol') == 1:
        return True

    if single_pass:
        
        main_geometry = checkInputs(node)

        if main_geometry is None:
            return False       
            
        existing_scene_viewer_data = clearExistingSceneViewers(node)

    try:

        # Start of This Pass ...

        # Starts the render
        print_progress = node.evalParm('printprogressofrops')
        rop_node = node.node(node.path() + '/opengl_vol_alpha')
        sleep(node.evalParm('warmuptime'))
        rop_node.render(ignore_inputs = True, ignore_bypass_flags = True, verbose = print_progress)
        rop_node = node.node(node.path() + '/opengl_nonvol_alpha')
        sleep(node.evalParm('warmuptime'))
        rop_node.render(ignore_inputs = True, ignore_bypass_flags = True, verbose = print_progress)
        updateTimeStamp(node, 'lb_timestamp_sa')

        success = True

    except Exception as exc:

        raise exc

    finally:

        # ... End of This Pass
    
        if single_pass:
            restoreExistingSceneViewers(node, existing_scene_viewer_data)
    
    return success



def renderNonEmissiveColor(node, single_pass = True, main_geometry = None):

    success = False

    if node.evalParm('renderer_nc') == 0: 
        return True

    # Ensures this variable exists so the 'finally' clause can always execute
    scene_viewer = None

    if single_pass:
        
        main_geometry = checkInputs(node)

        if main_geometry is None:
            return False        
            
        existing_scene_viewer_data = clearExistingSceneViewers(node)

    try:

        # Start of This Pass ...

        scene_viewer_node = mergeRenderGeometries(node, main_geometry, True)
    
        if scene_viewer_node is None:
            return False

        # Temporarily override settings on Pyro Bake Volume nodes
    
        pyro_bake_volumes = []
        scatter_toggles = []
        fire_toggles = []
        secfire_toggles = []
    
        for i in range(1, 6):
    
            idx = str(i)
            geo_path = node.evalParm('bakevolpath' + idx)
            pyro_bake_volume = node.node(geo_path)
    
            if type(pyro_bake_volume) is hou.SopNode:
    
                if pyro_bake_volume.type().name() == 'pyrobakevolume':
    
                    pyro_bake_volumes.append(pyro_bake_volume)
    
                    scatter_toggles.append(pyro_bake_volume.evalParm('enablescatter'))
                    fire_toggles.append(pyro_bake_volume.evalParm('enablefire'))
                    secfire_toggles.append(pyro_bake_volume.evalParm('enablesecfire'))
    
                    pyro_bake_volume.setParms({'enablescatter': 0, 'enablefire': 0, 'enablesecfire': 0})
    
        scene_viewer_node.setGenericFlag(hou.nodeFlag.Display, True)
        scene_viewer_node.setGenericFlag(hou.nodeFlag.Render, True)

        scene_viewer = setCommonSceneViewerSettings(node, scene_viewer_node, node.evalParm('viewportpadding'))
        viewport_data = setCommonViewportSettings(node, scene_viewer, 'lit')
        fb_settings = setCommonFlipbookSettings(node, scene_viewer)
    
        # Pass-specific viewport overrides
        # None
    
        setColorSpace(node, node.evalParm('colspace'), scene_viewer, viewport_data['settings'], fb_settings)
    
        # Starts the render
        fb_settings.output(node.evalParm('interdir') + 'NC.pic.gz')
        sleep(node.evalParm('warmuptime'))
        scene_viewer.flipbook(viewport_data['viewport'], fb_settings)
        updateTimeStamp(node, 'lb_timestamp_nc')

        success = True

    except Exception as exc:

        raise exc

    finally:

        closeSceneViewer(scene_viewer, scene_viewer_node)
    
        # Restores settings on the Pyro Bake Volume nodes
        for i in range(len(pyro_bake_volumes)):
    
            pyro_bake_volumes[i].parm('enablescatter').set(scatter_toggles[i])
            pyro_bake_volumes[i].parm('enablefire').set(fire_toggles[i])
            pyro_bake_volumes[i].parm('enablesecfire').set(secfire_toggles[i])
    
        # ... End of This Pass
    
        if single_pass:
            restoreExistingSceneViewers(node, existing_scene_viewer_data)

    return success



def renderMDC(node, single_pass = True):

    success = False

    if node.evalParm('renderer_mdc') == 0: 
        return True

    # Ensures this variable exists so the 'finally' clause can always execute
    scene_viewer = None

    if single_pass:
        
        main_geometry = checkInputs(node)

        if main_geometry is None:
            return False        
            
        existing_scene_viewer_data = clearExistingSceneViewers(node)

    try:

        # Start of This Pass ...

        scene_viewer_node = node.node(node.path() + '/mdc_c/geo/RENDER_MDC')
    
        if scene_viewer_node is None:
            return False
    
        scene_viewer_node = node.node(node.path() + '/mdc_b/geo/RENDER_MDC')
    
        if scene_viewer_node is None:
            return False
    
        scene_viewer_node = node.node(node.path() + '/mdc_a/geo/RENDER_MDC')
    
        if scene_viewer_node is None:
            return False
    
        # Temporarily override settings on Pyro Bake Volume nodes

        pyro_bake_volumes = []
        scatter_toggles = []
        fire_toggles = []
        secfire_toggles = []
        color_modes = []
        smoke_rs = []
        smoke_gs = []
        smoke_bs = []
        
        for i in range(1, 6):
    
            idx = str(i)
            geo_path = node.evalParm('bakevolpath' + idx)
            pyro_bake_volume = node.node(geo_path)
    
            if type(pyro_bake_volume) is hou.SopNode:
    
                if pyro_bake_volume.type().name() == 'pyrobakevolume':
    
                    pyro_bake_volumes.append(pyro_bake_volume)
    
                    scatter_toggles.append(pyro_bake_volume.evalParm('enablescatter'))
                    fire_toggles.append(pyro_bake_volume.evalParm('enablefire'))
                    secfire_toggles.append(pyro_bake_volume.evalParm('enablesecfire'))

                    color_mode = pyro_bake_volume.evalParm('smokecolormode')
                    r = pyro_bake_volume.evalParm('smokecolorr')
                    g = pyro_bake_volume.evalParm('smokecolorg')
                    b = pyro_bake_volume.evalParm('smokecolorb')

                    color_modes.append(color_mode)
                    smoke_rs.append(r)
                    smoke_gs.append(g)
                    smoke_bs.append(b)

                    if color_mode == 1:

                        color = pyro_bake_volume.parm('smokecolorramp').evalAsRamp().lookup(1.0)

                        r = color[0]
                        g = color[1]
                        b = color[2]

                    y = 0.2126 * r + 0.7152 * g + 0.0722 * b

                    pyro_bake_volume.setParms({'enablescatter': 0, 'enablefire': 0, 'enablesecfire': 0})
                    pyro_bake_volume.setParms({'smokecolormode': 0, 'smokecolorr': y, 'smokecolorg': y, 'smokecolorb': y})
    
    
        # MDC A Pass

        scene_viewer = setCommonSceneViewerSettings(node, scene_viewer_node, node.evalParm('viewportpadding'))
        viewport_data = setCommonViewportSettings(node, scene_viewer, 'lit')
        fb_settings = setCommonFlipbookSettings(node, scene_viewer)
    
        # Pass-specific viewport overrides
        viewport_data['settings'].showSpecular(False)
        viewport_data['settings'].showEmission(False)
        viewport_data['settings'].setLighting(hou.viewportLighting.HighQualityWithShadows)
        viewport_data['settings'].setShadowQuality(hou.viewportShadowQuality.AreaAA)
        
        setColorSpace(node, node.evalParm('colspace'), scene_viewer, viewport_data['settings'], fb_settings)
        
        # Starts the render
        fb_settings.output(node.evalParm('interdir') + 'MDCa.pic.gz')
        sleep(node.evalParm('warmuptime'))
        scene_viewer.flipbook(viewport_data['viewport'], fb_settings)
    
        closeSceneViewer(scene_viewer)


        # MDC B Pass

        scene_viewer_node = node.node(node.path() + '/mdc_b/geo/RENDER_MDC')

        scene_viewer = setCommonSceneViewerSettings(node, scene_viewer_node, node.evalParm('viewportpadding'))
        viewport_data = setCommonViewportSettings(node, scene_viewer, 'lit')
        fb_settings = setCommonFlipbookSettings(node, scene_viewer)
    
        # Pass-specific viewport overrides
        viewport_data['settings'].showSpecular(False)
        viewport_data['settings'].showEmission(False)
        viewport_data['settings'].setLighting(hou.viewportLighting.HighQualityWithShadows)
        viewport_data['settings'].setShadowQuality(hou.viewportShadowQuality.AreaAA)
        
        setColorSpace(node, node.evalParm('colspace'), scene_viewer, viewport_data['settings'], fb_settings)
        
        # Starts the render
        fb_settings.output(node.evalParm('interdir') + 'MDCb.pic.gz')
        sleep(node.evalParm('warmuptime'))
        scene_viewer.flipbook(viewport_data['viewport'], fb_settings)
    
        closeSceneViewer(scene_viewer)

    
        # MDC C Pass

        scene_viewer_node = node.node(node.path() + '/mdc_c/geo/RENDER_MDC')

        scene_viewer = setCommonSceneViewerSettings(node, scene_viewer_node, node.evalParm('viewportpadding'))
        viewport_data = setCommonViewportSettings(node, scene_viewer, 'lit')
        fb_settings = setCommonFlipbookSettings(node, scene_viewer)
    
        # Pass-specific viewport overrides
        viewport_data['settings'].showSpecular(False)
        viewport_data['settings'].showEmission(False)
        viewport_data['settings'].setLighting(hou.viewportLighting.HighQualityWithShadows)
        viewport_data['settings'].setShadowQuality(hou.viewportShadowQuality.AreaAA)
        
        setColorSpace(node, node.evalParm('colspace'), scene_viewer, viewport_data['settings'], fb_settings)
        
        # Starts the render
        fb_settings.output(node.evalParm('interdir') + 'MDCc.pic.gz')
        sleep(node.evalParm('warmuptime'))
        scene_viewer.flipbook(viewport_data['viewport'], fb_settings)
        updateTimeStamp(node, 'lb_timestamp_mdc')

        success = True

    except Exception as exc:

        raise exc

    finally:

        closeSceneViewer(scene_viewer)

        # Restores settings on the Pyro Bake Volume nodes
        for i in range(len(pyro_bake_volumes)):
    
            pyro_bake_volumes[i].parm('enablescatter').set(scatter_toggles[i])
            pyro_bake_volumes[i].parm('enablefire').set(fire_toggles[i])
            pyro_bake_volumes[i].parm('enablesecfire').set(secfire_toggles[i])
    
            pyro_bake_volumes[i].parm('smokecolormode').set(color_modes[i])
            pyro_bake_volumes[i].parm('smokecolorr').set(smoke_rs[i])
            pyro_bake_volumes[i].parm('smokecolorg').set(smoke_gs[i])
            pyro_bake_volumes[i].parm('smokecolorb').set(smoke_bs[i])
    
        # ... End of This Pass
    
        if single_pass:
            restoreExistingSceneViewers(node, existing_scene_viewer_data)
    
    return success



def renderSurfaceNormal(node, single_pass = True):

    success = False

    if node.evalParm('renderer_sn') == 0: 
        return True

    # Ensures this variable exists so the 'finally' clause can always execute
    scene_viewer = None

    if single_pass:
        
        main_geometry = checkInputs(node)

        if main_geometry is None:
            return False
            
        existing_scene_viewer_data = clearExistingSceneViewers(node)

    try:

        # Start of This Pass ...

        scene_viewer_node = node.node(node.path() + '/surface_normal/geo/RENDER_SN')
    
        if scene_viewer_node is None:
            return False
    
        scene_viewer = setCommonSceneViewerSettings(node, scene_viewer_node)
        viewport_data = setCommonViewportSettings(node, scene_viewer, 'unlit')
        fb_settings = setCommonFlipbookSettings(node, scene_viewer)
    
        # Pass-specific viewport overrides
        # None
    
        setColorSpace(node, 0, scene_viewer, viewport_data['settings'], fb_settings)
    
        # Starts the render
        fb_settings.output(node.evalParm('interdir') + 'SN.pic.gz')
        sleep(node.evalParm('warmuptime'))
        scene_viewer.flipbook(viewport_data['viewport'], fb_settings)
        updateTimeStamp(node, 'lb_timestamp_sn')

        success = True
    
    except Exception as exc:

        raise exc

    finally:

        closeSceneViewer(scene_viewer)
    
        # ... End of This Pass
    
        if single_pass:
            restoreExistingSceneViewers(node, existing_scene_viewer_data)
    
    return success



def renderMotionVector(node, single_pass = True):

    success = False

    if node.evalParm('renderer_mv') == 0: 
        return True

    # Ensures this variable exists so the 'finally' clause can always execute
    scene_viewer = None

    if single_pass:
        
        main_geometry = checkInputs(node)

        if main_geometry is None:
            return False        
            
        existing_scene_viewer_data = clearExistingSceneViewers(node)

    try:

        # Start of This Pass ...

        scene_viewer_node = node.node(node.path() + '/motion_vector/geo/RENDER_MV')
    
        if scene_viewer_node is None:
            return False
    
        scene_viewer = setCommonSceneViewerSettings(node, scene_viewer_node)
        viewport_data = setCommonViewportSettings(node, scene_viewer, 'unlit')
        fb_settings = setCommonFlipbookSettings(node, scene_viewer)
    
        # Pass-specific viewport overrides
        # None
    
        setColorSpace(node, 0, scene_viewer, viewport_data['settings'], fb_settings)
    
        # Starts the render
        fb_settings.output(node.evalParm('interdir') + 'MV.pic.gz')
        sleep(node.evalParm('warmuptime'))
        scene_viewer.flipbook(viewport_data['viewport'], fb_settings)
        updateTimeStamp(node, 'lb_timestamp_mv')

        success = True
    
    except Exception as exc:

        raise exc

    finally:

        closeSceneViewer(scene_viewer)
    
        # ... End of This Pass
    
        if single_pass:
            restoreExistingSceneViewers(node, existing_scene_viewer_data)
    
    return success



def renderDepth(node, single_pass = True):

    success = False

    if node.evalParm('renderer_d') == 0: 
        return True

    if single_pass:
        
        main_geometry = checkInputs(node)

        if main_geometry is None:
            return False        
            
        existing_scene_viewer_data = clearExistingSceneViewers(node)

    try:

        # Start of This Pass ...

        # Starts the render
        print_progress = node.evalParm('printprogressofrops')
        rop_node = node.node(node.path() + '/opengl_depth')
        sleep(node.evalParm('warmuptime'))
        rop_node.render(ignore_inputs = True, ignore_bypass_flags = True, verbose = print_progress)
        updateTimeStamp(node, 'lb_timestamp_d')

        success = True

    except Exception as exc:

        raise exc

    finally:

        # ... End of This Pass
    
        if single_pass:
            restoreExistingSceneViewers(node, existing_scene_viewer_data)
    
    return success



def renderAll(node):

    success = False

    main_geometry = checkInputs(node)
    
    if main_geometry is None:
        return False

    existing_scene_viewer_data = clearExistingSceneViewers(node)

    try:

        if renderFinalColor(node, False, main_geometry):
            if renderNonEmissiveColor(node, False, main_geometry):
                if renderMDC(node, False):
                    if renderSurfaceNormal(node, False):
                        if renderMotionVector(node, False):
                            renderDepth(node, False)

        success = True

    except Exception as exc:

        if type(exc) is not hou.OperationInterrupted:
            raise exc

    finally:

        restoreExistingSceneViewers(node, existing_scene_viewer_data)

    return success



# Composite


def reloadImageFile(node, relative_path):

    file_node = node.node(node.path() + relative_path)
    file_node.parm('reload').pressButton()

    return



def reloadFinalColor(node):

    reloadImageFile(node, '/comp_final_color/msg_final_color')

    if node.node(node.path() + '/comp_final_color/switch_combined_alphas').parm('index').eval() == 1:

        reloadImageFile(node, '/comp_final_color/msg_vol_alpha')
        reloadImageFile(node, '/comp_final_color/msg_nonvol_alpha')

    return



def setPreviewImage(node):

    preview_image = node.evalParm('previewimage')

    if preview_image == 0:
        return

    pinSelectionFollowingTabs(node)

    desktop = hou.ui.curDesktop()

    # Attempts to find a valid Compositor Viewer

    comp_viewer = desktop.paneTabOfType(hou.paneTabType.CompositorViewer)

    if comp_viewer is None:

        should_create_floating = 1

        scene_viewer = desktop.paneTabOfType(hou.paneTabType.SceneViewer)

        if scene_viewer is not None:

            pane = scene_viewer.pane()

            if pane is not None:

                should_create_floating = 0
                comp_viewer = pane.createTab(hou.paneTabType.CompositorViewer)  

        if should_create_floating == 1:

            panel = desktop.createFloatingPanel(hou.paneTabType.CompositorViewer, immediate = True)
            comp_viewer = panel.paneTabOfType(hou.paneTabType.CompositorViewer)

    if comp_viewer is None:

        print ("Failed to find or create a Composite View Tab.")
        return

    comp_viewer.setIsCurrentTab()
    comp_viewer.setPin(True)
    preview_node = node.node(node.path() + '/preview/OUT_PREVIEW')
    comp_viewer.setCurrentNode(preview_node)

    # Color space settings

    ocio_env = hou.getenv('OCIO')

    if node.evalParm('colspace') < 2 or ocio_env is None:

        comp_viewer.setUsingOCIO(False)
        hou.hscript('colorsettings -g 1.0 -c')

    else:

        comp_viewer.setUsingOCIO(True)

        if '/misc/labs_ocio/aces_config.ocio' in ocio_env:
            # Labs Minimal OCIO ACES:
            setOCIODisplayViewSafe('sRGB', 'Raw', comp_viewer)

        else:
            # Official OCIO ACES:
            setOCIODisplayViewSafe('ACES', 'Raw', comp_viewer)

    # Reloads dependent image files
    if preview_image == 1:

        reloadFinalColor(node)

    elif preview_image <= 3:

        reloadFinalColor(node)
        reloadImageFile(node, '/comp_non_emissive/msg_non_emissive_color')

    elif preview_image <= 9:

        reloadImageFile(node, '/comp_mdc/msg_mdc_a')
        reloadImageFile(node, '/comp_mdc/msg_mdc_b')
        reloadImageFile(node, '/comp_mdc/msg_mdc_c')

    elif preview_image == 10:

        reloadImageFile(node, '/comp_normal/msg_surface_normal')

    elif preview_image == 11:

        reloadImageFile(node, '/comp_mdc/msg_mdc_a')
        reloadImageFile(node, '/comp_mdc/msg_mdc_b')
        reloadImageFile(node, '/comp_mdc/msg_mdc_c')
        reloadImageFile(node, '/comp_normal/msg_surface_normal')

    elif preview_image <= 13:

        reloadFinalColor(node)
        reloadImageFile(node, '/comp_motion_vector/msg_motion_vector')

    elif preview_image == 14:

        reloadImageFile(node, '/comp_depth/msg_depth')

    elif preview_image <= 19:

        reloadFinalColor(node)
        reloadImageFile(node, '/comp_non_emissive/msg_non_emissive_color')
        reloadImageFile(node, '/comp_normal/msg_surface_normal')
        reloadImageFile(node, '/comp_mdc/msg_mdc_a')
        reloadImageFile(node, '/comp_mdc/msg_mdc_b')
        reloadImageFile(node, '/comp_mdc/msg_mdc_c')
        reloadImageFile(node, '/comp_motion_vector/msg_motion_vector')
        reloadImageFile(node, '/comp_depth/msg_depth')

    return



def stopPreviewImage(node):

    if node.evalParm('previewimage') > 0:
        node.setParms({'previewimage': 0})

    return



def exportTexture(node, texture_index):

    success = False

    try:

        stopPreviewImage(node)
    
        if node.evalParm('enabletex' + str(texture_index)):
    
            output_node = node.node(node.path() + '/channel_pack/ROP_TEX' + str(texture_index))
            output_node.render()

        success = True

    except Exception as exc:

        print ("Error in exporting Texture " + str(texture_index) + ".")
        raise exc

    return success



def exportAll(node):

    try:

        if exportTexture(node, 1):
            if exportTexture(node, 2):
                if exportTexture(node, 3):
                    if exportTexture(node, 4):
                        exportTexture(node, 5)

    except Exception as exc:

        if type(exc) is not hou.OperationInterrupted:
            raise exc

    return



def renderAndExport(node):

    if renderAll(node):
        exportAll(node)

    return