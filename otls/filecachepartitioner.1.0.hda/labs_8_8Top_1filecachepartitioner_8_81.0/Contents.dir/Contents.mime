MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY"

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename=".OPfallbacks"
Content-Type: application/external-reference

.OPfallbacks

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename=".OPdummydefs"
Content-Type: application/external-reference

.OPdummydefs

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="node_type"
Content-Type: text/plain

Top

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.init"
Content-Type: text/plain

type = labs::filecachepartitioner::1.0
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.def"
Content-Type: text/plain

comment ""
position -4.0227 0.57286
connectornextid 0
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress off colordefault on exposed on
outputsNamed3
{
}
inputsNamed3
{
}
inputs
{
}
stat
{
  create -1
  modify -1
  author christoss@oxbow
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.inp"
Content-Type: text/plain

30
0 0 6 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
1 3 6.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
2 6 7 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
3 9 7.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
4 12 8 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
5 15 8.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
6 18 9 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
7 21 9.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
8 24 10 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
9 27 10.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
10 30 11 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
11 33 11.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
12 36 12 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
13 39 12.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
14 42 13 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
15 45 13.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
16 48 14 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
17 51 14.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
18 54 15 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
19 57 15.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
20 60 16 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
21 63 16.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
22 66 17 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
23 69 17.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
24 72 18 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
25 75 18.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
26 78 19 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
27 81 19.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
28 84 20 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"
29 87 20.5 2 0 __NO_OWNER_NETWORK_BOX__ "FROMOUTPUT"

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/__stickynote2.postitinit"
Content-Type: text/plain

type = postitnote
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/__stickynote2.postitdef"
Content-Type: text/plain

text "Timeindependent:
Every incoming workitem will be partitioned into a single output partition

Timeindependent - Wedged:
* If the incoming workitem is wedged, partition it to the output partition that has the same wedgeindex as the incoming wedgenum attribute. If wedgenum is bigger then the number of output partitions, don't partition.
 
* If the incoming workitem is not wedged, every workitem partitioned to every output partition

Timedependent:
* If the incoming workitem has frames, parition it to the output partition with the same frame number. If the frame number is not in the range of the partition, don't partition.

* If  the incoming workitem has no frame, every workitem partitioned to every output partition

Timedependent - Wedged:
*If the incoming workitem has wedges and has frames find the partition with the same frame frame and wedge index (wedgenum) for partitioning. IF wedgenum or frame is not in the output partition,  don't partition
* If the incoming workitem has wedges and not frames find all partitions that has the same wedgeindex. otherwise don't partition
* If the incoming workitem doesn't have wedges, but has frames, partitione it to all partition with the same frame
* If the incoming workitem doesn't have any wedge and frame, partition it to all."
position 7 -4.08515
size 14 5.94531
flags = minimize off
stat
{
  create 1638554598
  modify 1638559767
  author ati@pop-os.localdomain
  access 0777
}
color UT_Color RGB 1 0.969 0.522 
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/filecachepartitioner1.init"
Content-Type: text/plain

type = pythonpartitioner
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/filecachepartitioner1.def"
Content-Type: text/plain

comment ""
position 1.5 2.9098
connectornextid 32
flags =  lock off model off template off footprint off xray off bypass off display off render on highlight off unload off savedata off compress off colordefault on exposed on
outputsNamed3
{
0 "output1"
}
inputsNamed3
{
1 	generic_generator 0 1 "input1"
2 	(0) "" 1 "input2"
3 	(1) "" 1 "input3"
4 	(2) "" 1 "input4"
5 	(3) "" 1 "input5"
6 	(4) "" 1 "input6"
7 	(5) "" 1 "input7"
8 	(6) "" 1 "input8"
9 	(7) "" 1 "input9"
10 	(8) "" 1 "input10"
11 	(9) "" 1 "input11"
12 	(10) "" 1 "input12"
13 	(11) "" 1 "input13"
14 	(12) "" 1 "input14"
15 	(13) "" 1 "input15"
16 	(14) "" 1 "input16"
17 	(15) "" 1 "input17"
18 	(16) "" 1 "input18"
19 	(17) "" 1 "input19"
20 	(18) "" 1 "input20"
21 	(19) "" 1 "input21"
22 	(20) "" 1 "input22"
23 	(21) "" 1 "input23"
24 	(22) "" 1 "input24"
25 	(23) "" 1 "input25"
26 	(24) "" 1 "input26"
27 	(25) "" 1 "input27"
28 	(26) "" 1 "input28"
29 	(27) "" 1 "input29"
30 	(28) "" 1 "input30"
31 	(29) "" 1 "input31"
}
inputs
{
0 	generic_generator 0 1
1 	(0) 0 1
2 	(1) 0 1
3 	(2) 0 1
4 	(3) 0 1
5 	(4) 0 1
6 	(5) 0 1
7 	(6) 0 1
8 	(7) 0 1
9 	(8) 0 1
10 	(9) 0 1
11 	(10) 0 1
12 	(11) 0 1
13 	(12) 0 1
14 	(13) 0 1
15 	(14) 0 1
16 	(15) 0 1
17 	(16) 0 1
18 	(17) 0 1
19 	(18) 0 1
20 	(19) 0 1
21 	(20) 0 1
22 	(21) 0 1
23 	(22) 0 1
24 	(23) 0 1
25 	(24) 0 1
26 	(25) 0 1
27 	(26) 0 1
28 	(27) 0 1
29 	(28) 0 1
30 	(29) 0 1
}
stat
{
  create -1
  modify -1
  author ati@pop-os.localdomain
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/filecachepartitioner1.spareparmdef"
Content-Type: text/plain

    parm {
        name    "savenodescript"
        baseparm
        label   "Save to Python Script"
        joinnext
        export  none
    }
    parm {
        name    "savenodehda"
        baseparm
        label   "Save to Digital Asset"
        export  none
    }
    parm {
        name    "sepparm"
        baseparm
        label   "Separator"
        export  none
    }
    group {
        name    "folder0"
        label   "General"

        groupcollapsible {
            name    "folder1"
            label   "Sequence"
            grouptag { "group_default" "1" }

            parm {
                name    "timedependent"
                label   "Time Dependent Cache"
                type    toggle
                default { "on" }
                parmtag { "autoscope" "0000000000000000" }
                parmtag { "script_callback_language" "python" }
            }
            parm {
                name    "f"
                label   "Frame Range"
                type    float
                size    3
                default { "$FSTART" "$FEND" "1" }
                hidewhen "{ timedependent != 1 }"
                range   { 1 240 }
                parmtag { "script_callback_language" "python" }
            }
            parm {
                name    "waitforallframes"
                label   "Wait for All Frames"
                type    toggle
                default { "0" }
                hidewhen "{ timedependent != 1 }"
                parmtag { "script_callback_language" "python" }
            }
        }

        parm {
            name    "enablewedging"
            label   "Enable Wedging"
            type    toggle
            nolabel
            default { "0" }
            parmtag { "script_callback_language" "python" }
        }
        groupcollapsible {
            name    "folder2"
            label   "Wedging"
            grouptag { "sidefx::header_parm" "wedgecount" }
            grouptag { "sidefx::header_toggle" "enablewedging" }

            parm {
                name    "wedgecount"
                label   "Wedge Count"
                type    integer
                default { "1" }
                disablewhen "{ enablewedging != 1 }"
                range   { 1! 50 }
                parmtag { "autoscope" "0000000000000000" }
                parmtag { "script_callback_language" "python" }
            }
        }

    }

    group {
        name    "folder0_1"
        label   "Partition"

        parm {
            name    "partition"
            baseparm
            label   "onPartition Callback"
            export  none
        }
    }

    group {
        name    "folder0_2"
        label   "Merge Attributes"

        parm {
            name    "pdg_partitionmerge"
            baseparm
            label   "Merge Input Attributes"
            invisible
            export  none
        }
        multiparm {
            name    "pdg_partitionmergeattributes"
            label    "Merge Operations"
            baseparm
            default 1

            parm {
                name    "pdg_partitionmergeoperation#"
                baseparm
                label   "Apply Operation"
                export  none
            }
            parm {
                name    "pdg_partitionmergepattern#"
                baseparm
                label   "To Attributes"
                export  none
            }
            parm {
                name    "pdg_partitionmergepreserve#"
                baseparm
                label   "Preserve Arrays"
                export  none
            }
            parm {
                name    "sepparm3_#"
                baseparm
                label   "Separator"
                export  none
            }
        }

    }

    group {
        name    "folder0_3"
        label   "Advanced"

        parm {
            name    "pdg_partitionwhen"
            baseparm
            label   "Partition When"
            export  none
        }
        parm {
            name    "pdg_partitiontargettype"
            baseparm
            label   "Partition Target(s)"
            export  none
        }
        parm {
            name    "pdg_partitiontarget"
            baseparm
            label   "Custom Target Node"
            export  none
        }
        parm {
            name    "sepparm2"
            baseparm
            label   "Separator"
            export  none
        }
        parm {
            name    "pdg_partitionsplit"
            baseparm
            label   "Use Split by Attribute"
            nolabel
            joinnext
            export  none
        }
        parm {
            name    "pdg_partitionsplitattrib"
            baseparm
            label   "Split by Attribute"
            export  none
        }
        parm {
            name    "pdg_partitionsplitmissing"
            baseparm
            label   "Missing Attribute"
            export  none
        }
        parm {
            name    "pdg_partitionsplitdefault"
            baseparm
            label   "Default Value"
            export  none
        }
        parm {
            name    "pdg_partitionsplitpartial"
            baseparm
            label   "Allow Partial Matches"
            export  none
        }
        parm {
            name    "sepparm3"
            baseparm
            label   "Separator"
            export  none
        }
        parm {
            name    "pdg_partitionframe"
            baseparm
            label   "Set Partition Frame To"
            export  none
        }
        parm {
            name    "pdg_partitionsort"
            baseparm
            label   "Sort Contents By"
            joinnext
            export  none
        }
        parm {
            name    "pdg_partitionsortdirection"
            baseparm
            label   "Sort Direction"
            nolabel
            export  none
        }
        parm {
            name    "pdg_partitionsortattrib"
            baseparm
            label   "Sort Attribute"
            export  none
        }
        parm {
            name    "pdg_partitionsortrequired"
            baseparm
            label   "Prioritize Required Work Items"
            export  none
        }
        parm {
            name    "pdg_partitionstoreids"
            baseparm
            label   "Enable Store Items to Attrib"
            nolabel
            joinnext
            export  none
        }
        parm {
            name    "pdg_partitionidattrib"
            baseparm
            label   "Store Items to Attrib"
            export  none
        }
    }


--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/filecachepartitioner1.chn"
Content-Type: text/plain

{
    channel f1 {
      lefttype = extend
      righttype = extend
      flags = 0
      segment { length = 0 expr = ch(\"../f1\") }
    }
    channel f2 {
      lefttype = extend
      righttype = extend
      flags = 0
      segment { length = 0 expr = ch(\"../f2\") }
    }
    channel timedependent {
      lefttype = extend
      righttype = extend
      default = 1
      flags = 0
      segment { length = 0 value = 1 1 expr = ch(\"../timedependent\") }
    }
    channel f3 {
      lefttype = extend
      righttype = extend
      default = 1
      flags = 0
      segment { length = 0 value = 1 1 expr = "ch(\"../f3\") / ch(\"../substeps\")" }
    }
    channel enablewedging {
      lefttype = extend
      righttype = extend
      flags = 0
      segment { length = 0 expr = ch(\"../enablewedging\") }
    }
    channel wedgecount {
      lefttype = extend
      righttype = extend
      default = 1
      flags = 0
      segment { length = 0 value = 1 1 expr = ch(\"../wedgecount\") }
    }
    channel waitforallframes {
      lefttype = extend
      righttype = extend
      flags = 0
      segment { length = 0 expr = ch(\"../waitforallframes\") }
    }
  }

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/filecachepartitioner1.parm"
Content-Type: text/plain

{
version 0.8
savenodescript	[ 0	locks=0 ]	(	0	)
savenodehda	[ 0	locks=0 ]	(	0	)
sepparm	[ 0	locks=0 ]	(	)
partition2	[ 0	locks=0 ]	(	0	0	0	)
partition	[ 0	locks=0 ]	(	"# Custom onPartition callback logic. The following global variables are available:
#
# self                -    A reference to the current pdg.Node instance
# partition_holder    -    A pdg.PartitionHolder for adding work items to partitions
# work_items          -    The list of upstream work items to partition

import hou
node = hou.pwd()

# PARMS
timedependent = node.evalParm(\"timedependent\")
start = node.evalParm(\"f1\")
end = node.evalParm(\"f2\")
stepsize = node.evalParm(\"f3\")
waitforallframes = node.evalParm(\"waitforallframes\")
dowedging = node.parm(\"enablewedging\").evalAsInt() 
wedgecount = node.parm(\"wedgecount\").evalAsInt()

# FUNCTIONS
def isGeneric(work_item):
    if work_item.hasFrame:
        return False
    return True
    
def isWedged(work_item):
    if work_item.attrib(\"wedgeindex\") and work_item.attrib(\"wedgenum\"):
        return True
    return False
    
def isTimeDependent(work_item):
    '''
        Checks the type of work item. Returns None if the work item has no frame attribute.
        If it has, checks if the range and frame is not 1 (Time Dependent), otherwise
        it is Time Independent
    '''
   
    if isGeneric(work_item):
        return False
        
    frame = work_item.frame
    range = work_item.floatAttribArray('range') 
    if range[0] == range[1] == range[2] == frame == 1:
        return False
    else:
        return True
        
def splitWorkItems(work_items):
    '''
        Split upstream work items if they internal (generic_generator) or external
    '''
    
    internal_items = []
    external_items = []
    
    for item in work_items:
        if item.attrib(\"__internal\"):
            internal_items.append(item)        
        else:
            external_items.append(item)
    
    return internal_items, external_items
            
class PartitionTable():
    def __init__(self, timedependent, start, end, stepsize, waitforallframes, dowedging, wedgecount):        
        self.timedependent = timedependent
        self.start = start if timedependent else 1
        self.end = end if timedependent else 1
        self.stepsize = stepsize if timedependent else 1      
        self.waitforallframes = waitforallframes
        self.dowedging = dowedging
        self.wedgecount = wedgecount -1 if dowedging else 0        
        self.table = {} # partition_index: frame, wedgeindex, list of work_items in partition....
        self.buildPartitionTable()
        #self.printTable()

    def getPartitionCount(self):
        return len(self.table)
        
    def buildPartitionTable(self):
        
        self.range_values = pdg.ValuePattern(\"{}-{}:{}\".format(self.start,self.end,self.stepsize)).floatArray(inclusive=True)
        self.wedge_values = pdg.ValuePattern(\"{}-{}\".format(0,self.wedgecount)).intArray(inclusive=True)
                
        i = 0
        for wvalue in self.wedge_values:
            for rvalue in self.range_values:
                self.table[i] = [rvalue, wvalue]
                i += 1
                
    def addItemToAllPartitions(self, work_item):
        for index, values in self.table.items():
            self.table[index].append(work_item)
            
    def addItemToFirstWedge(self, work_item):
        '''
            Used when timeindependent-wedged
            Number of wedges = the number of partitions
        '''
        wedgenum = work_item.intAttribValue('wedgenum')
        # if upstream wedgenum is in table, add it
        # otherwise skip it, downstream not dependent on it
        if wedgenum in self.wedge_values: 
            self.table[wedgenum].append(work_item)     
    
    def addItemToFirstFrame(self, work_item):
        '''
            Used when timedependent
            Number of frames = the number of partitions
        '''
        frame = work_item.frame        
        # if upstream wedgeindex is in table, add it        
        if frame in self.range_values:                
            self.table[self.range_values.index(frame)].append(work_item) 
                   
    def addItemToSubframes(self, work_item):
        '''
            Used when timedependent
            For each incoming work item, it finds all matching
            generated work items.
        '''    
        frame = work_item.frame   
        
        # Only run if subframes are generated
        if self.stepsize < 1:
            stepsize = work_item.floatAttribArray('range')[2]
            minframe = frame - stepsize
            maxframe = frame + stepsize
           
            for idx, frame in enumerate(self.range_values):
                if (frame > minframe) and (frame < maxframe):
                    self.table[idx].append(work_item)     
            
    def addItemByFrameAndWedge(self, work_item):
        '''
            Used when timedependent-wedged
            Find right index with frame and wedgeindex
        '''    
        
        frame = work_item.frame
        wedgenum = work_item.intAttribValue('wedgenum')
            
        # if we have a partition with the same frame and wedgenum
        # add it to the paritition table
        # otherise skip it, downstream not dependent on it
        
        for idx, values in self.table.items(): 
            partition_frame = values[0]
            partition_wedgeindex = values[1]
            if frame == partition_frame and wedgenum == partition_wedgeindex:
                self.table[idx].append(work_item)
                break

    def addItemToWedgedSubframes(self, work_item):
        '''
            Used when timedependent
            For each incoming work item, it finds all matching
            generated work items.
        '''    
        frame = work_item.frame   
        wedgenum = work_item.intAttribValue('wedgenum')
        
        # Only run if subframes are generated
        if self.stepsize < 1:
            stepsize = work_item.floatAttribArray('range')[2]
            minframe = frame - stepsize
            maxframe = frame + stepsize
            for idx, values in self.table.items(): 
                partition_frame = values[0]
                partition_wedgeindex = values[1]
                if wedgenum == partition_wedgeindex:
                    if (partition_frame > minframe) and (partition_frame < maxframe):
                        self.table[idx].append(work_item)
                    
    def addItemToWedges(self, work_item):
        '''
            Used when timedependent-wedged
            Find all wedgeindexes
        '''  
        
        wedgenum = work_item.intAttribValue('wedgenum')
        
        indices = []
        for index, values in self.table.items():
            partition_wedgeindex = values[1]
            if wedgenum == partition_wedgeindex:
                self.table[index].append(work_item)    

    def addItemToFrames(self, work_item):
        '''
            Used when timedependent-wedged
            Find all frames
        '''      
        frame = work_item.frame
        
        indices = []
        for index, values in self.table.items():
            partition_frame = values[0]
            if frame == partition_frame:
                self.table[index].append(work_item)  

    def addItemToSubframesWedged(self, work_item):
        '''
            Used when timedependent-wedged
        '''    
        frame = work_item.frame   
        
        # Only run if subframes are generated
        if self.stepsize < 1:
            stepsize = work_item.floatAttribArray('range')[2]
            minframe = frame - stepsize
            maxframe = frame + stepsize
            for idx, values in self.table.items(): 
                partition_frame = values[0]               
                if (partition_frame > minframe) and (partition_frame < maxframe):
                    self.table[idx].append(work_item)
                    
    def sortItems(self, work_items):

        if self.waitforallframes: 
            for work_item in work_items:
                self.addItemToAllPartitions(work_item)
            return 
            
        # timedependent-wedged
        if timedependent and dowedging:
            for work_item in work_items:
                if isWedged(work_item):                    
                    if isTimeDependent(work_item):
                        # Match by frame and wedgeindex
                        self.addItemByFrameAndWedge(work_item)  
                        # Partition subframes
                        self.addItemToWedgedSubframes(work_item)
                    else:
                        # Match by only wedgeindex
                        self.addItemToWedges(work_item)               
                else:
                    if isTimeDependent(work_item):
                        # Match by only frame
                        self.addItemToFrames(work_item)
                        self.addItemToSubframesWedged(work_item)
                    else:
                        # Each partition is dependent on the work item
                        self.addItemToAllPartitions(work_item)        
            
        # timedependent
        if timedependent and not dowedging:
            for work_item in work_items:
                if isTimeDependent(work_item):
                    # Each work item is put in partition with it's corresponding frame       
                    self.addItemToFirstFrame(work_item)
                    # Partition subframes
                    self.addItemToSubframes(work_item)
                else:
                    # Each partition is dependent on the work item
                    self.addItemToAllPartitions(work_item)         
            
        # timeindependent-wedged
        if not timedependent and dowedging:
            for work_item in work_items:   
                if isWedged(work_item):
                    # Has wedge attribs
                    # Each work item is put in partition with it's corresponding wedgeindex
                    self.addItemToFirstWedge(work_item)                
                else:
                    # Feneric work item
                    # Each partition is dependent on the work item
                    self.addItemToAllPartitions(work_item)
                    
        # timeindependent             
        if not timedependent and not dowedging:           
            for work_item in work_items:
                # Each partition is dependent on the work item
                self.addItemToAllPartitions(work_item)
        
    def updatePartitioner(self, partition_holder, internal_items):
        for index, values in self.table.items():
            #print(index)
            # Work item from first input
            # Every partition has to contain an internal work item
            #print(internal_items[index].name)
            partition_holder.addItemToPartition(internal_items[index], index, required=True)
            
            # Work items from other inputs
            external_items = values[2:] # discard frame and wedgeindex
            if external_items:
                for external_item in external_items:
                    partition_holder.addItemToPartition(external_item, index)   
                    #print(external_item.name)
                    
            partition_holder.setPartitionFrame(index,internal_items[index].frame)
                    
    def printTable(self):
        print(\"--------------\")
        for index, values in self.table.items(): 
            print(\"Index: {}, {}-{}\".format(index,values[0],values[1]))       

# MAIN
internal_items, external_items = splitWorkItems(work_items)
partition_table = PartitionTable(timedependent,
                                 start,
                                 end,
                                 stepsize,
                                 waitforallframes,
                                 dowedging,
                                 wedgecount)       
partition_table.sortItems(external_items)
partition_table.updatePartitioner(partition_holder, internal_items)"	)
pdg_partitionmerge	[ 0	locks=0 ]	(	"off"	)
pdg_partitionmergeattributes	[ 0	locks=0 ]	(	2	)
pdg_partitionwhen	[ 0	locks=0 ]	(	"0"	)
pdg_partitiontargettype	[ 0	locks=0 ]	(	"0"	)
pdg_partitiontarget	[ 0	locks=0 ]	(	""	)
sepparm2	[ 0	locks=0 ]	(	)
pdg_partitionsplit	[ 0	locks=0 ]	(	"off"	)
pdg_partitionsplitattrib	[ 0	locks=0 ]	(	""	)
pdg_partitionsplitmissing	[ 0	locks=0 ]	(	"0"	)
pdg_partitionsplitdefault	[ 0	locks=0 ]	(	""	)
pdg_partitionsplitpartial	[ 0	locks=0 ]	(	"off"	)
sepparm3	[ 0	locks=0 ]	(	)
pdg_partitionframe	[ 0	locks=0 ]	(	"1"	)
pdg_partitionsort	[ 0	locks=0 ]	(	"1"	)
pdg_partitionsortdirection	[ 0	locks=0 ]	(	"0"	)
pdg_partitionsortattrib	[ 0	locks=0 ]	(	""	)
pdg_partitionsortrequired	[ 0	locks=0 ]	(	"on"	)
pdg_partitionstoreids	[ 0	locks=0 ]	(	"off"	)
pdg_partitionidattrib	[ 0	locks=0 ]	(	partitionitems	)
pdg_partitionmergeoperation1	[ 0	locks=0	autoscope=0	autosel=4294967295 ]	(	"1"	)
pdg_partitionmergepattern1	[ 0	locks=0	autoscope=0	autosel=4294967295 ]	(	*	)
pdg_partitionmergepreserve1	[ 0	locks=0 ]	(	"off"	)
sepparm3_1	[ 0	locks=0 ]	(	)
folder0	[ 0	locks=0 ]	(	1	1	1	1	)
folder1	[ 0	locks=0 ]	(	1	)
timedependent	[ 8	locks=0 ]	(	[ timedependent	1 ] 	)
f	[ 0	locks=0 ]	(	[ f1	0 ] 	[ f2	0 ] 	[ f3	1 ] 	)
waitforallframes	[ 8	locks=0 ]	(	[ waitforallframes	0 ] 	)
enablewedging	[ 8	locks=0 ]	(	[ enablewedging	0 ] 	)
folder2	[ 0	locks=0 ]	(	0	)
wedgecount	[ 0	locks=0 ]	(	[ wedgecount	1 ] 	)
pdg_partitionmergeoperation2	[ 0	locks=0 ]	(	"0"	)
pdg_partitionmergepattern2	[ 0	locks=0 ]	(	"`ifs(ch(\"../enablewedging\"),\"__internal\",\"__internal wedgetotal wedgecount wedgeindex wedgenum\")`"	)
pdg_partitionmergepreserve2	[ 0	locks=0 ]	(	"off"	)
sepparm3_2	[ 0	locks=0 ]	(	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/filecachepartitioner1.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"___EXTERNAL___"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/generic_generator.init"
Content-Type: text/plain

type = pythonprocessor
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/generic_generator.def"
Content-Type: text/plain

comment "Based on the settings the number of needed work items is known. Generate them with the right attributes. This will ensure to have exactly the right amount of work items, regardless any input."
position -2.5 4.9098
connectornextid 1
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress off colordefault on exposed on displaycomment on
outputsNamed3
{
0 "output1"
}
inputsNamed3
{
}
inputs
{
}
stat
{
  create -1
  modify -1
  author ati@pop-os.localdomain
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/generic_generator.spareparmdef"
Content-Type: text/plain

    parm {
        name    "savenodescript"
        baseparm
        label   "Save to Python Script"
        joinnext
        export  none
    }
    parm {
        name    "savenodehda"
        baseparm
        label   "Save to Digital Asset"
        export  none
    }
    parm {
        name    "sepparm2"
        baseparm
        label   "Separator"
        export  none
    }
    group {
        name    "folder0"
        label   "General"

        groupcollapsible {
            name    "folder1"
            label   "Sequence"
            grouptag { "group_default" "1" }

            parm {
                name    "timedependent"
                label   "Time Dependent Cache"
                type    toggle
                default { "on" }
                parmtag { "autoscope" "0000000000000000" }
                parmtag { "script_callback_language" "python" }
            }
            parm {
                name    "f"
                label   "Frame Range"
                type    float
                size    3
                default { "$FSTART" "$FEND" "1" }
                hidewhen "{ timedependent != 1 }"
                range   { 1 240 }
                parmtag { "script_callback_language" "python" }
            }
        }

        parm {
            name    "enablewedging"
            label   "Enable Wedging"
            type    toggle
            nolabel
            default { "0" }
            parmtag { "script_callback_language" "python" }
        }
        groupcollapsible {
            name    "folder2"
            label   "Wedging"
            grouptag { "sidefx::header_parm" "wedgecount" }
            grouptag { "sidefx::header_toggle" "enablewedging" }

            parm {
                name    "wedgecount"
                label   "Wedge Count"
                type    integer
                default { "1" }
                disablewhen "{ enablewedging != 1 }"
                range   { 1! 50 }
                parmtag { "autoscope" "0000000000000000" }
                parmtag { "script_callback_language" "python" }
            }
        }

    }

    group {
        name    "folder0_1"
        label   "Processor"

        parm {
            name    "pdg_workitemgeneration"
            baseparm
            label   "Generate When"
            export  none
        }
        parm {
            name    "pdg_command"
            baseparm
            label   "Command"
            export  none
        }
        parm {
            name    "sepparm"
            baseparm
            label   "Separator"
            export  none
        }
        group {
            name    "callbacks6"
            label   "Generate"

            parm {
                name    "generate"
                baseparm
                label   "onGenerate Callback"
                export  none
            }
        }

        group {
            name    "callbacks6_1"
            label   "Regenerate"

            parm {
                name    "useregeneratestatic"
                baseparm
                label   "Use Custom Regenerate Implementation"
                export  none
            }
            parm {
                name    "regeneratestatic"
                baseparm
                label   "onRegenerate Callback"
                export  none
            }
        }

        group {
            name    "callbacks6_2"
            label   "Add Internal Dependencies"

            parm {
                name    "addinternaldependencies"
                baseparm
                label   "onAddInternalDependencies Callback"
                export  none
            }
        }

        group {
            name    "callbacks6_3"
            label   "Cook Task"

            parm {
                name    "cooktask"
                baseparm
                label   "onCookTask Callback"
                export  none
            }
        }

        group {
            name    "callbacks6_4"
            label   "Node Options"

            parm {
                name    "servicename"
                baseparm
                label   "Service Name"
                export  none
            }
            parm {
                name    "sepparm3"
                baseparm
                label   "Separator"
                export  none
            }
            parm {
                name    "alwaysregenerate"
                baseparm
                label   "Always Regenerate"
                export  none
            }
            parm {
                name    "dirtyonregenerate"
                baseparm
                label   "Dirty on Regenerate"
                export  none
            }
            parm {
                name    "dirtyonincomplete"
                baseparm
                label   "Dirty on Incomplete"
                export  none
            }
            parm {
                name    "sepparm4"
                baseparm
                label   "Separator"
                export  none
            }
            parm {
                name    "requiresgeneratedinputs"
                baseparm
                label   "Requires Generated Inputs"
                export  none
            }
            parm {
                name    "requiresscenefile"
                baseparm
                label   "Requires Scene File"
                export  none
            }
        }

    }

    group {
        name    "folder0_2"
        label   "Files"

        multiparm {
            name    "pdgnodedeps"
            label    "File Dependencies"
            baseparm
            default 1

            parm {
                name    "pdgnodedep#"
                baseparm
                label   "File Path"
                export  none
            }
        }

    }

    group {
        name    "folder0_3"
        label   "Schedulers"

        parm {
            name    "topscheduler"
            baseparm
            label   "TOP Scheduler Override"
            joinnext
            export  none
        }
        parm {
            name    "addjobparms"
            baseparm
            label   "Add Job Parms"
            nolabel
            export  none
        }
        parm {
            name    "sepparm5"
            baseparm
            label   "Separator"
            export  none
        }
        parm {
            name    "pdg_workitemlabel"
            baseparm
            label   "Work Item Label"
            joinnext
            export  none
        }
        parm {
            name    "pdg_workitemlabelexpr"
            baseparm
            label   "Label Expression"
            nolabel
            export  none
        }
        parm {
            name    "pdg_workitempriority"
            baseparm
            label   "Work Item Priority"
            joinnext
            export  none
        }
        parm {
            name    "pdg_workitempriorityexpr"
            baseparm
            label   "Priority Expression"
            nolabel
            export  none
        }
    }


--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/generic_generator.chn"
Content-Type: text/plain

{
    channel f1 {
      lefttype = extend
      righttype = extend
      flags = 0
      segment { length = 0 expr = ch(\"../f1\") }
    }
    channel f2 {
      lefttype = extend
      righttype = extend
      flags = 0
      segment { length = 0 expr = ch(\"../f2\") }
    }
    channel timedependent {
      lefttype = extend
      righttype = extend
      default = 1
      flags = 0
      segment { length = 0 value = 1 1 expr = ch(\"../timedependent\") }
    }
    channel f3 {
      lefttype = extend
      righttype = extend
      default = 1
      flags = 0
      segment { length = 0 value = 1 1 expr = "ch(\"../f3\") / ch(\"../substeps\")" }
    }
    channel enablewedging {
      lefttype = extend
      righttype = extend
      flags = 0
      segment { length = 0 expr = ch(\"../enablewedging\") }
    }
    channel wedgecount {
      lefttype = extend
      righttype = extend
      default = 1
      flags = 0
      segment { length = 0 value = 1 1 expr = ch(\"../wedgecount\") }
    }
  }

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/generic_generator.parm"
Content-Type: text/plain

{
version 0.8
savenodescript	[ 0	locks=0 ]	(	0	)
savenodehda	[ 0	locks=0 ]	(	0	)
sepparm2	[ 0	locks=0 ]	(	)
processor	[ 0	locks=0 ]	(	0	0	0	)
pdg_workitemgeneration	[ 0	locks=0 ]	(	"2"	)
pdg_command	[ 0	locks=0 ]	(	""	)
sepparm	[ 0	locks=0 ]	(	)
callbacks	[ 0	locks=0 ]	(	0	0	0	0	0	)
generate	[ 0	locks=0 ]	(	"# Called when this node should generate new work items from upstream items.
#
# self             -   A reference to the current pdg.Node instance
# item_holder      -   A pdg.WorkItemHolder for constructing and adding work items
# upstream_items   -   The list of work items in the node above, or empty list if there are no inputs
# generation_type  -   The type of generation, e.g. pdg.generationType.Static, Dynamic, or Regenerate

import hou
node = hou.pwd()

# PARMS
timedependent = node.evalParm(\"timedependent\")
start = node.evalParm(\"f1\") if timedependent else 1
end = node.evalParm(\"f2\") if timedependent else 1
stepsize = node.evalParm(\"f3\") if timedependent else 1

dowedging = node.parm(\"enablewedging\").evalAsInt() 
wedgecount = node.parm(\"wedgecount\").evalAsInt()-1 if dowedging else 0  

range_values = pdg.ValuePattern(\"{}-{}:{}\".format(start,end,stepsize)).floatArray(inclusive=True)
wedge_values = pdg.ValuePattern(\"{}-{}\".format(0,wedgecount)).intArray(inclusive=True)
        
index = 0
for wedgenum in wedge_values:
    for frame in range_values:
        new_item = item_holder.addWorkItem(index=index)
        new_item.setIntAttrib('__internal',1)
        new_item.setFloatAttrib('range',(start,end,stepsize))
        new_item.setFrame(frame,stepsize)   
        
        if dowedging:
            new_item.setIntAttrib('wedgecount',wedgecount + 1)
            new_item.setIntAttrib('wedgetotal',wedgecount + 1)
            new_item.setIntAttrib('wedgeindex',wedgenum)
            new_item.setIntAttrib('wedgenum',wedgenum)
            
        index += 1
"	)
useregeneratestatic	[ 0	locks=0 ]	(	"off"	)
regeneratestatic	[ 0	locks=0 ]	(	"# Called when this node may need to regenerate existing work items
#
# self           -   A reference to the current pdg.Node instance
# item_holder    -   A pdg.WorkItemHolder for constructing and adding new work items
# existing_items -   The existing work items in the node
# upstream_items -   The list of work items in the node above, or empty list
# generation_type -   The type of generation, e.g. pdg.generationType.Static, Dynamic, or Regenerate"	)
addinternaldependencies	[ 0	locks=0 ]	(	"# Called when the node has generated work items so that dependencies can
# be added between work items in this node.
#
# self              -   A reference to the current pdg.Node instance
# dependency_holder -   A pdg.WorkItemHolder for adding pairs of items that should have a dependency
# internal_items    -   The list of items, either all static items or a group of dynamic items
# is_static         -   Boolean indicating if the items list contains static items
"	)
cooktask	[ 0	locks=0 ]	(	"# Called when an in process work item needs to cook. In process work items
# are created by passing the `inProcess=True` flag when constructing the item in
# the `Generate` callback
#
# self              -   A reference to the current pdg.Node instance
# work_item         -   The work item being cooked by this callback"	)
servicename	[ 0	locks=0 ]	(	""	)
sepparm3	[ 0	locks=0 ]	(	)
alwaysregenerate	[ 0	locks=0 ]	(	"off"	)
dirtyonregenerate	[ 0	locks=0 ]	(	"off"	)
dirtyonincomplete	[ 0	locks=0 ]	(	"off"	)
sepparm4	[ 0	locks=0 ]	(	)
requiresgeneratedinputs	[ 0	locks=0 ]	(	"off"	)
requiresscenefile	[ 0	locks=0 ]	(	"off"	)
pdgnodedeps	[ 0	locks=0 ]	(	1	)
topscheduler	[ 0	locks=0 ]	(	""	)
addjobparms	[ 0	locks=0 ]	(	0	)
sepparm5	[ 0	locks=0 ]	(	)
pdg_workitemlabel	[ 0	locks=0 ]	(	"0"	)
pdg_workitemlabelexpr	[ 0	locks=0 ]	(	""	)
pdg_workitempriority	[ 0	locks=0 ]	(	"0"	)
pdg_workitempriorityexpr	[ 0	locks=0 ]	(	0	)
pdgnodedep1	[ 0	locks=0 ]	(	""	)
folder0	[ 0	locks=0 ]	(	0	0	0	0	)
folder1	[ 0	locks=0 ]	(	1	)
timedependent	[ 8	locks=0 ]	(	[ timedependent	1 ] 	)
f	[ 0	locks=0 ]	(	[ f1	0 ] 	[ f2	0 ] 	[ f3	1 ] 	)
enablewedging	[ 8	locks=0 ]	(	[ enablewedging	0 ] 	)
folder2	[ 0	locks=0 ]	(	0	)
wedgecount	[ 0	locks=0 ]	(	[ wedgecount	1 ] 	)
callbacks6	[ 0	locks=0 ]	(	0	0	0	0	0	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/generic_generator.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	},
	"___toolcount___":{
		"type":"string",
		"value":"1"
	},
	"___toolid___":{
		"type":"string",
		"value":"object_cop2plane"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.init"
Content-Type: text/plain

type = output
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.def"
Content-Type: text/plain

comment ""
position 1.5 -4.0902
connectornextid 1
flags =  lock off model off template off footprint off xray off bypass off display on render off highlight off unload off savedata off compress off colordefault on exposed on
outputsNamed3
{
}
inputsNamed3
{
0 	remove_attribs 1 1 "input1"
}
inputs
{
0 	remove_attribs 0 1
}
stat
{
  create -1
  modify -1
  author ati@pop-os.localdomain
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.parm"
Content-Type: text/plain

{
version 0.8
outputidx	[ 0	locks=0 ]	(	0	)
pdg_workitemlabel	[ 0	locks=0 ]	(	"0"	)
pdg_workitemlabelexpr	[ 0	locks=0 ]	(	""	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/output0.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":"___EXTERNAL___"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/remove_attribs.init"
Content-Type: text/plain

type = pythonprocessor
matchesdef = 0

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/remove_attribs.def"
Content-Type: text/plain

comment ""
position 1.5 0.000709096
connectornextid 2
flags =  lock off model off template off footprint off xray off bypass off display off render off highlight off unload off savedata off compress off colordefault on exposed on
outputsNamed3
{
1 "output1"
}
inputsNamed3
{
0 	filecachepartitioner1 0 1 "input1"
}
inputs
{
0 	filecachepartitioner1 0 1
}
stat
{
  create -1
  modify -1
  author ati@pop-os.localdomain
  access 0777
}
color UT_Color RGB 0.8 0.8 0.8 
delscript ""
exprlanguage hscript
end

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/remove_attribs.spareparmdef"
Content-Type: text/plain

    parm {
        name    "savenodescript"
        baseparm
        label   "Save to Python Script"
        joinnext
        export  none
    }
    parm {
        name    "savenodehda"
        baseparm
        label   "Save to Digital Asset"
        export  none
    }
    parm {
        name    "sepparm2"
        baseparm
        label   "Separator"
        export  none
    }
    group {
        name    "folder0"
        label   "General"

        parm {
            name    "enablewedging"
            label   "Enable Wedging"
            type    toggle
            default { "0" }
            parmtag { "script_callback_language" "python" }
        }
    }

    group {
        name    "folder0_1"
        label   "Processor"

        parm {
            name    "pdg_workitemgeneration"
            baseparm
            label   "Generate When"
            export  none
        }
        parm {
            name    "pdg_command"
            baseparm
            label   "Command"
            export  none
        }
        parm {
            name    "sepparm"
            baseparm
            label   "Separator"
            export  none
        }
        group {
            name    "callbacks6"
            label   "Generate"

            parm {
                name    "generate"
                baseparm
                label   "onGenerate Callback"
                export  none
            }
        }

        group {
            name    "callbacks6_1"
            label   "Regenerate"

            parm {
                name    "useregeneratestatic"
                baseparm
                label   "Use Custom Regenerate Implementation"
                export  none
            }
            parm {
                name    "regeneratestatic"
                baseparm
                label   "onRegenerate Callback"
                export  none
            }
        }

        group {
            name    "callbacks6_2"
            label   "Add Internal Dependencies"

            parm {
                name    "addinternaldependencies"
                baseparm
                label   "onAddInternalDependencies Callback"
                export  none
            }
        }

        group {
            name    "callbacks6_3"
            label   "Cook Task"

            parm {
                name    "cooktask"
                baseparm
                label   "onCookTask Callback"
                export  none
            }
        }

        group {
            name    "callbacks6_4"
            label   "Node Options"

            parm {
                name    "servicename"
                baseparm
                label   "Service Name"
                export  none
            }
            parm {
                name    "sepparm3"
                baseparm
                label   "Separator"
                export  none
            }
            parm {
                name    "alwaysregenerate"
                baseparm
                label   "Always Regenerate"
                export  none
            }
            parm {
                name    "dirtyonregenerate"
                baseparm
                label   "Dirty on Regenerate"
                export  none
            }
            parm {
                name    "dirtyonincomplete"
                baseparm
                label   "Dirty on Incomplete"
                export  none
            }
            parm {
                name    "sepparm4"
                baseparm
                label   "Separator"
                export  none
            }
            parm {
                name    "requiresgeneratedinputs"
                baseparm
                label   "Requires Generated Inputs"
                export  none
            }
            parm {
                name    "requiresscenefile"
                baseparm
                label   "Requires Scene File"
                export  none
            }
        }

    }

    group {
        name    "folder0_2"
        label   "Files"

        multiparm {
            name    "pdgnodedeps"
            label    "File Dependencies"
            baseparm
            default 1

            parm {
                name    "pdgnodedep#"
                baseparm
                label   "File Path"
                export  none
            }
        }

    }

    group {
        name    "folder0_3"
        label   "Schedulers"

        parm {
            name    "topscheduler"
            baseparm
            label   "TOP Scheduler Override"
            joinnext
            export  none
        }
        parm {
            name    "addjobparms"
            baseparm
            label   "Add Job Parms"
            nolabel
            export  none
        }
        parm {
            name    "sepparm5"
            baseparm
            label   "Separator"
            export  none
        }
        parm {
            name    "pdg_workitemlabel"
            baseparm
            label   "Work Item Label"
            joinnext
            export  none
        }
        parm {
            name    "pdg_workitemlabelexpr"
            baseparm
            label   "Label Expression"
            nolabel
            export  none
        }
        parm {
            name    "pdg_workitempriority"
            baseparm
            label   "Work Item Priority"
            joinnext
            export  none
        }
        parm {
            name    "pdg_workitempriorityexpr"
            baseparm
            label   "Priority Expression"
            nolabel
            export  none
        }
    }


--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/remove_attribs.chn"
Content-Type: text/plain

{
    channel enablewedging {
      lefttype = extend
      righttype = extend
      flags = 0
      segment { length = 0 expr = ch(\"../enablewedging\") }
    }
  }

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/remove_attribs.parm"
Content-Type: text/plain

{
version 0.8
savenodescript	[ 0	locks=0 ]	(	0	)
savenodehda	[ 0	locks=0 ]	(	0	)
sepparm2	[ 0	locks=0 ]	(	)
processor	[ 0	locks=0 ]	(	0	0	0	)
pdg_workitemgeneration	[ 0	locks=0 ]	(	"2"	)
pdg_command	[ 0	locks=0 ]	(	""	)
sepparm	[ 0	locks=0 ]	(	)
callbacks	[ 0	locks=0 ]	(	0	0	0	0	0	)
generate	[ 0	locks=0 ]	(	"# Called when this node should generate new work items from upstream items.
#
# self             -   A reference to the current pdg.Node instance
# item_holder      -   A pdg.WorkItemHolder for constructing and adding work items
# upstream_items   -   The list of work items in the node above, or empty list if there are no inputs
# generation_type  -   The type of generation, e.g. pdg.generationType.Static, Dynamic, or Regenerate

import hou
node = hou.pwd()

dowedging = node.evalParm(\"enablewedging\")

def checkAndErase(work_item, attrib):
    if work_item.attrib(attrib):
        new_item.eraseAttrib(attrib)

for upstream_item in upstream_items:
    new_item = item_holder.addWorkItem(parent=upstream_item)
    
    checkAndErase(new_item, \"__internal\")
    checkAndErase(new_item, \"partitionsize\")
    
    # Remove any wedging related attribute when no wedging is set.
    if not dowedging:        
        checkAndErase(new_item, \"wedgeindex\")
        checkAndErase(new_item, \"wedgenum\")
        checkAndErase(new_item, \"wedgecount\")
        checkAndErase(new_item, \"wedgetotal\")
        
        if new_item.attrib(\"wedgeattribs\"):
            for wedgeattrib in new_item.stringAttribArray(\"wedgeattribs\"):
                checkAndErase(new_item, wedgeattrib)
            new_item.eraseAttrib(\"wedgeattribs\")    
            "	)
useregeneratestatic	[ 0	locks=0 ]	(	"off"	)
regeneratestatic	[ 0	locks=0 ]	(	"# Called when this node may need to regenerate existing work items
#
# self           -   A reference to the current pdg.Node instance
# item_holder    -   A pdg.WorkItemHolder for constructing and adding new work items
# existing_items -   The existing work items in the node
# upstream_items -   The list of work items in the node above, or empty list
# generation_type -   The type of generation, e.g. pdg.generationType.Static, Dynamic, or Regenerate"	)
addinternaldependencies	[ 0	locks=0 ]	(	"# Called when the node has generated work items so that dependencies can
# be added between work items in this node.
#
# self              -   A reference to the current pdg.Node instance
# dependency_holder -   A pdg.WorkItemHolder for adding pairs of items that should have a dependency
# internal_items    -   The list of items, either all static items or a group of dynamic items
# is_static         -   Boolean indicating if the items list contains static items
"	)
cooktask	[ 0	locks=0 ]	(	"# Called when an in process work item needs to cook. In process work items
# are created by passing the `inProcess=True` flag when constructing the item in
# the `Generate` callback
#
# self              -   A reference to the current pdg.Node instance
# work_item         -   The work item being cooked by this callback"	)
servicename	[ 0	locks=0 ]	(	""	)
sepparm3	[ 0	locks=0 ]	(	)
alwaysregenerate	[ 0	locks=0 ]	(	"off"	)
dirtyonregenerate	[ 0	locks=0 ]	(	"off"	)
dirtyonincomplete	[ 0	locks=0 ]	(	"off"	)
sepparm4	[ 0	locks=0 ]	(	)
requiresgeneratedinputs	[ 0	locks=0 ]	(	"off"	)
requiresscenefile	[ 0	locks=0 ]	(	"off"	)
pdgnodedeps	[ 0	locks=0 ]	(	1	)
topscheduler	[ 0	locks=0 ]	(	""	)
addjobparms	[ 0	locks=0 ]	(	0	)
sepparm5	[ 0	locks=0 ]	(	)
pdg_workitemlabel	[ 0	locks=0 ]	(	"0"	)
pdg_workitemlabelexpr	[ 0	locks=0 ]	(	""	)
pdg_workitempriority	[ 0	locks=0 ]	(	"0"	)
pdg_workitempriorityexpr	[ 0	locks=0 ]	(	0	)
pdgnodedep1	[ 0	locks=0 ]	(	""	)
folder0	[ 0	locks=0 ]	(	1	1	1	1	)
enablewedging	[ 8	locks=0 ]	(	[ enablewedging	0 ] 	)
callbacks6	[ 0	locks=0 ]	(	0	0	0	0	0	)
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot/remove_attribs.userdata"
Content-Type: text/plain

{
	"___Version___":{
		"type":"string",
		"value":""
	},
	"___toolcount___":{
		"type":"string",
		"value":"1"
	},
	"___toolid___":{
		"type":"string",
		"value":"object_cop2plane"
	}
}

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.order"
Content-Type: text/plain

4
filecachepartitioner1
generic_generator
output0
remove_attribs

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY
Content-Disposition: attachment; filename="hdaroot.net"
Content-Type: text/plain

1

--HOUDINIMIMEBOUNDARY0xD3ADD339-0x00000F49-0x56B122C9-0x00000001HOUDINIMIMEBOUNDARY--
